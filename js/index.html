<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>JavaScript</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<link rel="stylesheet" href="../app.css">
<script src="//code.jquery.com/jquery.min.js"></script>
</head>
<body>
<div class="container">
<p>主要内容来自 <a target="_blank" rel="external nofollow" href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">廖雪峰博客</a>，略有改动。版权归廖雪峰所有</p>
<h1>JavaScript简介</h1>
<h4 id="javascript-">JavaScript历史</h4>
<p>要了解JavaScript，我们首先要回顾一下JavaScript的诞生。</p>
<p>在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。</p>
<p>由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。</p>
<p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>
<h4 id="ecmascript">ECMAScript</h4>
<p>因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。</p>
<p>所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。</p>
<p>那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。</p>
<p>不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为JavaScript就行了。</p>
<h4 id="javascript-">JavaScript版本</h4>
<p>JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。</p>
<p>此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。</p>
<p>由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。</p>
<p>不过，JavaScript的核心语法并没有多大变化。我们的教程会先讲JavaScript最核心的用法，然后，针对ES6讲解新增特性。</p>
<h1>快速入门</h1>
<p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;script&gt;
    alert('Hello, world');
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  ...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>由<code>&lt;script&gt;...&lt;/script&gt;</code>包含的代码就是JavaScript代码，它将直接被浏览器执行。</p>
<p>第二种方法是把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src="..."&gt;&lt;/script&gt;</code>引入这个文件：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;script src="/static/js/abc.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  ...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样，<code>/static/js/abc.js</code>就会被浏览器执行。</p>
<p>把JavaScript代码放入一个单独的<code>.js</code>文件中更利于维护代码，并且多个页面可以各自引用同一份<code>.js</code>文件。</p>
<p>可以在同一个页面中引入多个<code>.js</code>文件，还可以在页面中多次编写<code>&lt;script&gt; js代码... &lt;/script&gt;</code>，浏览器按照顺序依次执行。</p>
<p>有些时候你会看到<code>&lt;script&gt;</code>标签还设置了一个<code>type</code>属性：</p>
<pre><code>&lt;script type="text/javascript"&gt;
  ...
&lt;/script&gt;
</code></pre>
<p>但这是没有必要的，因为默认的<code>type</code>就是JavaScript，所以不必显式地把<code>type</code>指定为JavaScript。</p>
<h4 id="-javascript">如何编写JavaScript</h4>
<p>可以用任何文本编辑器来编写JavaScript代码。这里我们推荐以下几种文本编辑器：</p>
<h5 id="sublime-text">Sublime Text</h5>
<p>免费，但不注册会不定时弹出提示框。</p>
<h5 id="notepad-">Notepad++</h5>
<p>免费</p>
<p><em>注意</em>：不可以用Word或写字板来编写JavaScript或HTML，因为带格式的文本保存后不是<em>纯文本文件</em>，无法被浏览器正常读取。</p>
<h4 id="-javascript">如何运行JavaScript</h4>
<p>要让浏览器运行JavaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript，然后，让浏览器加载该HTML页面，就可以执行JavaScript代码。</p>
<p>你也许会想，直接在我的硬盘上创建好HTML和JavaScript文件，然后用浏览器打开，不就可以看到效果了吗？</p>
<p>这种方式运行部分JavaScript代码没有问题，但由于浏览器的安全限制，以<code>file://</code>开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以<code>http://</code>开头的地址来正常执行所有JavaScript代码。</p>
<p>不过，开始学习阶段，你无须关心如何搭建开发环境的问题，我们提供在页面输入JavaScript代码并直接运行的功能，让你专注于JavaScript的学习。</p>
<p>试试直接点击“Run”按钮执行下面的JavaScript代码：</p>
<pre>
<code class="x-javascript">
// 以//开头直到行末的是注释，将被浏览器忽略
// 第一个JavaScript代码:
----
alert('Hello, world');
</code>
</pre>
<p>浏览器将弹出一个对话框，显示“Hello, world”。你也可以修改两个单引号中间的内容，再试着运行。</p>
<h4 id="-">调试</h4>
<p>俗话说得好，“工欲善其事，必先利其器。”，写JavaScript的时候，如果期望显示<code>ABC</code>，结果却显示<code>XYZ</code>，到底代码哪里出了问题？不要抓狂，也不要泄气，作为小白，要坚信：JavaScript本身没有问题，浏览器执行也没有问题，有问题的一定是我的代码。</p>
<p>如何找出问题代码？这就需要调试。</p>
<p>怎么在浏览器中调试JavaScript代码呢？</p>
<p>首先，你需要安装Google Chrome浏览器，Chrome浏览器对开发者非常友好，可以让你方便地调试JavaScript代码。从这里<a href="https://www.google.com/chrome/browser/desktop/index.html?system=true&amp;standalone=1">下载Chrome浏览器</a>。打开网页出问题的童鞋请移步<a href="http://pan.baidu.com/s/1qWMaZSg#path=%252Fchrome">国内镜像</a>。</p>
<p>安装后，随便打开一个网页，然后点击菜单“查看(View)”-“开发者(Developer)”-“开发者工具(Developer Tools)”，浏览器窗口就会一分为二，下方就是开发者工具：</p>
<p><img src="files/attachments/001435888338188c0b13adb5b2b4a4f985c7a1ccd926cb6000.jpeg" alt="chrome-HOWTO"></p>
<p>先点击“控制台(Console)“，在这个面板里可以直接输入JavaScript代码，按回车后执行。</p>
<p>要查看一个变量的内容，在Console中输入<code>console.log(a);</code>，回车后显示的值就是变量的内容。</p>
<p>关闭Console请点击右上角的“×”按钮。请熟练掌握Console的使用方法，在编写JavaScript代码时，经常需要在Console运行测试代码。</p>
<p>如果你对自己还有更高的要求，可以研究开发者工具的“源码(Sources)”，掌握断点、单步执行等高级调试技巧。</p>
<h4 id="-">练习</h4>
<p>打开<a href="http://www.sina.com.cn/">新浪首页</a>，然后查看页面源代码，找一找引入的JavaScript文件和直接编写在页面中的JavaScript代码。然后在Chrome中打开开发者工具，在控制台输入<code>console.log('Hello');</code>，回车查看JavaScript代码执行结果。</p>
<h2>基本语法</h2>
<h4 id="-">语法</h4>
<p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</p>
<p><em>注意</em>：让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略<code>;</code>，所有语句都会添加<code>;</code>。</p>
<p>例如，下面的一行代码就是一个完整的赋值语句：</p>
<pre><code>var x = 1;
</code></pre>
<p>下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：</p>
<pre><code>'Hello, world';
</code></pre>
<p>下面的一行代码包含两个语句，每个语句用<code>;</code>表示语句结束：</p>
<pre><code>var x = 1; var y = 2; // 不建议一行写多个语句!
</code></pre>
<p>语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行<code>{...}</code>中的所有语句：</p>
<pre><code>if (2 &gt; 1) {
    x = 1;
    y = 2;
    z = 3;
}
</code></pre>
<p>注意花括号<code>{...}</code>内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。</p>
<p><code>{...}</code>还可以嵌套，形成层级结构：</p>
<pre><code>if (2 &gt; 1) {
    x = 1;
    y = 2;
    z = 3;
    if (x &lt; y) {
        z = 4;
    }
    if (x &gt; y) {
        z = 5;
    }
}
</code></pre>
<p>JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。</p>
<h4 id="-">注释</h4>
<p>以<code>//</code>开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</p>
<pre><code>// 这是一行注释
alert('hello'); // 这也是注释
</code></pre>
<p>另一种块注释是用<code>/*...*/</code>把多行字符包裹起来，把一大“块”视为一个注释：</p>
<pre><code>/* 从这里开始是块注释
仍然是注释
仍然是注释
注释结束 */
</code></pre>
<p>练习：</p>
<p>分别利用行注释和块注释把下面的语句注释掉，使它不再执行：</p>
<pre>
<code class="x-javascript">
// 请注释掉下面的语句:
----
alert('我不想执行');
alert('我也不想执行');
</code>
</pre>
<h4 id="-">大小写</h4>
<p>请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</p>
<h2>数据类型和变量</h2>
<h4 id="-">数据类型</h4>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：</p>
<h5 id="number">Number</h5>
<p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
<pre><code>123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
</code></pre>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等，它们和十进制表示的数值完全一样。</p>
<p>Number可以直接做四则运算，规则和数学一致：</p>
<pre><code>1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
</code></pre>
<p>注意<code>%</code>是求余运算。</p>
<h5 id="-">字符串</h5>
<p>字符串是以单引号'或双引号"括起来的任意文本，比如<code>'abc'</code>，<code>"xyz"</code>等等。请注意，<code>''</code>或<code>""</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>'abc'</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。</p>
<h5 id="-">布尔值</h5>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来：</p>
<pre><code>true; // 这是一个true值
false; // 这是一个false值
2 &gt; 1; // 这是一个true值
2 &gt;= 3; // 这是一个false值
</code></pre>
<p><code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code>：</p>
<pre><code>true &amp;&amp; true; // 这个&amp;&amp;语句计算结果为true
true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false
false &amp;&amp; true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false
</code></pre>
<p><code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code>：</p>
<pre><code>false || false; // 这个||语句计算结果为false
true || false; // 这个||语句计算结果为true
false || true || false; // 这个||语句计算结果为true
</code></pre>
<p><code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>：</p>
<pre><code>! true; // 结果为false
! false; // 结果为true
! (2 &gt; 5); // 结果为true
</code></pre>
<p>布尔值经常用在条件判断中，比如：</p>
<pre><code>var age = 15;
if (age &gt;= 18) {
    alert('adult');
} else {
    alert('teenager');
}
</code></pre>
<h4 id="-">比较运算符</h4>
<p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p>
<pre><code>2 &gt; 5; // false
5 &gt;= 2; // true
7 == 7; // true
</code></pre>
<p>实际上，JavaScript允许对任意数据类型做比较：</p>
<pre><code>false == 0; // true
false === 0; // false
</code></pre>
<p>要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
<p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<pre><code>NaN === NaN; // false
</code></pre>
<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p>
<pre><code>isNaN(NaN); // true
</code></pre>
<p>最后要注意浮点数的相等比较：</p>
<pre><code>1 / 3 === (1 - 2 / 3); // false
</code></pre>
<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<pre><code>Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true
</code></pre>
<h5 id="null-undefined">null和undefined</h5>
<p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>''</code>不同，<code>0</code>是一个数值，<code>''</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p>
<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>
<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>
<h5 id="-">数组</h5>
<p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<pre><code>[1, 2, 3.14, 'Hello', null, true];
</code></pre>
<p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<pre><code>new Array(1, 2, 3); // 创建了数组[1, 2, 3]
</code></pre>
<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
<pre><code>var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
</code></pre>
<h5 id="-">对象</h5>
<p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<pre><code>var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
</code></pre>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>'Bob'</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<pre><code>person.name; // 'Bob'
person.zipcode; // null
</code></pre>
<h4 id="-">变量</h4>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p>
<pre><code>var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = '007'; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
</code></pre>
<p>变量名也可以用中文，但是，请不要给自己找麻烦。</p>
<p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p>
<pre><code>var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
</code></pre>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p>
<pre><code>int a = 123; // a是整数类型变量，类型用int申明
a = "ABC"; // 错误：不能把字符串赋给整型变量
</code></pre>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<pre><code>var x = 10;
x = x + 2;
</code></pre>
<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p>
<h4 id="strict-">strict模式</h4>
<p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<pre><code>i = 10; // i现在是全局变量
</code></pre>
<p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p>
<p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<pre><code>'use strict';
</code></pre>
<p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<p>来测试一下你的浏览器是否能支持strict模式：</p>
<pre>
<code class="x-javascript">
'use strict';
// 如果浏览器支持strict模式，
// 下面的代码将报ReferenceError错误:
----
abc = 'Hello, world';
alert(abc);
</code>
</pre>
<p>运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。</p>
<p>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。</p>
<h2>字符串</h2>
<p>JavaScript的字符串就是用<code>''</code>或<code>""</code>括起来的字符表示。</p>
<p>如果<code>'</code>本身也是一个字符，那就可以用<code>""</code>括起来，比如<code>"I'm OK"</code>包含的字符是<code>I</code>，<code>'</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p>
<p>如果字符串内部既包含<code>'</code>又包含<code>"</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<pre><code>'I\'m \"OK\"!';
</code></pre>
<p>表示的字符串内容是：<code>I'm "OK"!</code></p>
<p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。</p>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示，例如：</p>
<pre><code>'\x41'; // 完全等同于 'A'
</code></pre>
<p>还可以用<code>\u####</code>表示一个Unicode字符：</p>
<pre><code>'\u4e2d\u6587'; // 完全等同于 '中文'
</code></pre>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用<em>`</em> ... <em>`</em>表示：</p>
<pre><code>`这是一个
多行
字符串`;
</code></pre>
<p>练习：测试你的浏览器是否支持ES6标准，如果不支持，请把多行字符串用<code>\n</code>重新表示出来：</p>
<pre>
<code class="x-javascript">
// 如果浏览器不支持ES6，将报SyntaxError错误:
----
alert(`多行
字符串
测试`);
</code>
</pre>
<p>字符串常见的操作如下：</p>
<pre><code>var s = 'Hello, world!';
s.length; // 13
</code></pre>
<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<pre><code>var s = 'Hello, world!';

s[0]; // 'H'
s[6]; // ' '
s[7]; // 'w'
s[12]; // '!'
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
</code></pre>
<p><em>需要特别注意的是</em>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<pre><code>var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
</code></pre>
<p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<h4 id="touppercase">toUpperCase</h4>
<p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<pre><code>var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'
</code></pre>
<h4 id="tolowercase">toLowerCase</h4>
<p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<pre><code>var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'
</code></pre>
<h4 id="indexof">indexOf</h4>
<p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<pre><code>var s = 'hello, world';
s.indexOf('world'); // 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
</code></pre>
<h4 id="substring">substring</h4>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<pre><code>var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
</code></pre>
<h2>数组</h2>
<p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<pre><code>var arr = [1, 2, 3.14, 'Hello', null, true];
arr.length; // 6
</code></pre>
<p><em>请注意</em>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<pre><code>var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
</code></pre>
<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<pre><code>var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
</code></pre>
<p><em>请注意</em>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<pre><code>var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
</code></pre>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<h4 id="indexof">indexOf</h4>
<p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<pre><code>var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
</code></pre>
<p>注意了，数字<code>30</code>和字符串<code>'30'</code>是不同的元素。</p>
<h4 id="slice">slice</h4>
<p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<pre><code>var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
</code></pre>
<p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<pre><code>var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
</code></pre>
<h4 id="push-pop">push和pop</h4>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<pre><code>var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []
</code></pre>
<h4 id="unshift-shift">unshift和shift</h4>
<p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<pre><code>var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []
</code></pre>
<h4 id="sort">sort</h4>
<p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<pre><code>var arr = ['B', 'C', 'A'];
arr.sort();
arr; // ['A', 'B', 'C']
</code></pre>
<p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
<h4 id="reverse">reverse</h4>
<p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p>
<pre><code>var arr = ['one', 'two', 'three'];
arr.reverse();
arr; // ['three', 'two', 'one']
</code></pre>
<h4 id="splice">splice</h4>
<p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<pre><code>var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
</code></pre>
<h4 id="concat">concat</h4>
<p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<pre><code>var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
</code></pre>
<p><em>请注意</em>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<pre><code>var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
</code></pre>
<h4 id="join">join</h4>
<p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<pre><code>var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
</code></pre>
<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4 id="-">多维数组</h4>
<p>如果数组的某个元素又是一个<code>Array</code>，则可以形成多维数组，例如：</p>
<pre><code>var arr = [[1, 2, 3], [400, 500, 600], '-'];
</code></pre>
<p>上述<code>Array</code>包含3个元素，其中头两个元素本身也是<code>Array</code>。</p>
<p>练习：如何通过索引取到<code>500</code>这个值：</p>
<pre>
<code class="x-javascript">
'use strict';
var arr = [[1, 2, 3], [400, 500, 600], '-'];
----
var x = ??;
----
alert(x); // x应该为500
</code>
</pre>
<h4 id="-">小结</h4>
<p><code>Array</code>提供了一种顺序存储一组元素的功能，并可以按索引来读写。</p>
<p>练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：<code>欢迎XXX，XXX，XXX和XXX同学！</code>：</p>
<pre>
<code class="x-javascript">
'use strict';
var arr = ['小明', '小红', '大军', '阿黄'];
----
alert('???');
</code>
</pre>
<h2>对象</h2>
<p>JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：</p>
<pre><code>var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
</code></pre>
<p>JavaScript用一个<code>{...}</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<p>上述对象申明了一个<code>name</code>属性，值是<code>'小明'</code>，<code>birth</code>属性，值是<code>1990</code>，以及其他一些属性。最后，把这个对象赋值给变量<code>xiaoming</code>后，就可以通过变量<code>xiaoming</code>来获取小明的属性了：</p>
<pre><code>xiaoming.name; // '小明'
xiaoming.birth; // 1990
</code></pre>
<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>''</code>括起来：</p>
<pre><code>var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
</code></pre>
<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>''</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>['xxx']</code>来访问：</p>
<pre><code>xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
</code></pre>
<p>也可以用<code>xiaohong['name']</code>来访问<code>xiaohong</code>的<code>name</code>属性，不过<code>xiaohong.name</code>的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过<code>object.prop</code>的形式访问一个属性了。</p>
<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code>：</p>
<pre><code>var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
</code></pre>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<pre><code>var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
</code></pre>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<pre><code>var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
</code></pre>
<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<pre><code>'toString' in xiaoming; // true
</code></pre>
<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<pre><code>var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
</code></pre>
<h2>条件判断</h2>
<p>JavaScript使用<code>if () { ... } else { ... }</code>来进行条件判断。例如，根据年龄显示不同内容，可以用<code>if</code>语句实现如下：</p>
<pre><code>var age = 20;
if (age &gt;= 18) { // 如果age &gt;= 18为true，则执行if语句块
    alert('adult');
} else { // 否则执行else语句块
    alert('teenager');
}
</code></pre>
<p>其中<code>else</code>语句是可选的。如果语句块只包含一条语句，那么可以省略<code>{}</code>：</p>
<pre><code>var age = 20;
if (age &gt;= 18)
    alert('adult');
else
    alert('teenager');
</code></pre>
<p>省略<code>{}</code>的危险之处在于，如果后来想添加一些语句，却忘了写<code>{}</code>，就改变了<code>if...else...</code>的语义，例如：</p>
<pre><code>var age = 20;
if (age &gt;= 18)
    alert('adult');
else
    console.log('age &lt; 18'); // 添加一行日志
    alert('teenager'); // &lt;- 这行语句已经不在else的控制范围了
</code></pre>
<p>上述代码的<code>else</code>子句实际上只负责执行<code>console.log('age &lt; 18');</code>，原有的<code>alert('teenager');</code>已经不属于<code>if...else...</code>的控制范围了，它每次都会执行。</p>
<p>相反地，有<code>{}</code>的语句就不会出错：</p>
<pre><code>var age = 20;
if (age &gt;= 18) {
    alert('adult');
} else {
    console.log('age &lt; 18');
    alert('teenager');
}
</code></pre>
<p>这就是为什么我们建议永远都要写上<code>{}</code>。</p>
<h4 id="-">多行条件判断</h4>
<p>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：</p>
<pre><code>var age = 3;
if (age &gt;= 18) {
    alert('adult');
} else if (age &gt;= 6) {
    alert('teenager');
} else {
    alert('kid');
}
</code></pre>
<p>上述多个<code>if...else...</code>的组合实际上相当于两层<code>if...else...</code>：</p>
<pre><code>var age = 3;
if (age &gt;= 18) {
    alert('adult');
} else {
    if (age &gt;= 6) {
        alert('teenager');
    } else {
        alert('kid');
    }
}
</code></pre>
<p>但是我们通常把<code>else if</code>连写在一起，来增加可读性。这里的<code>else</code>略掉了<code>{}</code>是没有问题的，因为它只包含一个<code>if</code>语句。注意最后一个单独的<code>else</code>不要略掉<code>{}</code>。</p>
<p><em>请注意</em>，<code>if...else...</code>语句的执行特点是二选一，在多个<code>if...else...</code>语句中，如果某个条件成立，则后续就不再继续判断了。</p>
<p>试解释为什么下面的代码显示的是<code>teenager</code>：</p>
<pre>
<code class="x-javascript">
'use strict';
var age = 20;
----
if (age &gt;= 6) {
    alert('teenager');
} else if (age &gt;= 18) {
    alert('adult');
} else {
    alert('kid');
}
</code>
</pre>
<p>由于<code>age</code>的值为<code>20</code>，它实际上同时满足条件<code>age &gt;= 6</code>和<code>age &gt;= 18</code>，这说明条件判断的顺序非常重要。请修复后让其显示<code>adult</code>。</p>
<p>如果<code>if</code>的条件判断语句结果不是<code>true</code>或<code>false</code>怎么办？例如：</p>
<pre><code>var s = '123';
if (s.length) { // 条件计算结果为3
    //
}
</code></pre>
<p>JavaScript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>''</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此上述代码条件判断的结果是<code>true</code>。</p>
<h4 id="-">练习</h4>
<p>小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p>
<ul>
<li>低于18.5：过轻</li>
<li>18.5-25：正常</li>
<li>25-28：过重</li>
<li>28-32：肥胖</li>
<li>高于32：严重肥胖</li>
</ul>
<p>用<code>if...else...</code>判断并显示结果：</p>
<pre>
<code class="x-javascript">
'use strict';

var height = parseFloat(prompt('请输入身高(m):'));
var weight = parseFloat(prompt('请输入体重(kg):'));
----
var bmi = ???;
if ...
</code>
</pre>
<h2>循环</h2>
<h4 id="-">循环</h4>
<p>要计算1+2+3，我们可以直接写表达式：</p>
<pre><code>1 + 2 + 3; // 6
</code></pre>
<p>要计算1+2+3+...+10，勉强也能写出来。</p>
<p>但是，要计算1+2+3+...+10000，直接写表达式就不可能了。</p>
<p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p>
<p>JavaScript的循环有两种，一种是<code>for</code>循环，通过初始条件、结束条件和递增条件来循环执行语句块：</p>
<pre><code>var x = 0;
var i;
for (i=1; i&lt;=10000; i++) {
    x = x + i;
}
x; // 50005000
</code></pre>
<p>让我们来分析一下<code>for</code>循环的控制条件：</p>
<ul>
<li>i=1 这是初始条件，将变量i置为1；</li>
<li>i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；</li>
<li>i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件<code>i&lt;=10000</code>而退出循环。</li>
</ul>
<h4 id="-">练习</h4>
<p>利用<code>for</code>循环计算<code>1 * 2 * 3 * ... * 10</code>的结果：</p>
<pre>
<code class="x-javascript">
'use strict';
----
var x = ?;
var i;
for ...
----
if (x === 3628800) {
    alert('1 x 2 x 3 x ... x 10 = ' + x);
}
else {
    alert('计算错误');
}
</code>
</pre>
<p><code>for</code>循环最常用的地方是利用索引来遍历数组：</p>
<pre><code>var arr = ['Apple', 'Google', 'Microsoft'];
var i, x;
for (i=0; i&lt;arr.length; i++) {
    x = arr[i];
    alert(x);
}
</code></pre>
<p><code>for</code>循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用<code>break</code>语句退出循环，否则就是死循环：</p>
<pre><code>var x = 0;
for (;;) { // 将无限循环下去
    if (x &gt; 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}
</code></pre>
<h4 id="for-in">for ... in</h4>
<p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<pre><code>var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    alert(key); // 'name', 'age', 'city'
}
</code></pre>
<p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p>
<pre><code>var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        alert(key); // 'name', 'age', 'city'
    }
}
</code></pre>
<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<pre><code>var a = ['A', 'B', 'C'];
for (var i in a) {
    alert(i); // '0', '1', '2'
    alert(a[i]); // 'A', 'B', 'C'
}
</code></pre>
<p><em>请注意</em>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
<h4 id="while">while</h4>
<p><code>for</code>循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的<code>for</code>循环容易让人看不清循环的逻辑，此时用<code>while</code>循环更佳。</p>
<p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<pre><code>var x = 0;
var n = 99;
while (n &gt; 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
</code></pre>
<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足<code>while</code>条件，循环退出。</p>
<h4 id="do-while">do ... while</h4>
<p>最后一种循环是<code>do { ... } while()</code>循环，它和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：</p>
<pre><code>var n = 0;
do {
    n = n + 1;
} while (n &lt; 100);
n; // 100
</code></pre>
<p>用<code>do { ... } while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p>
<h4 id="-">练习</h4>
<p>请利用循环遍历数组中的每个名字，并显示<code>Hello, xxx!</code>：</p>
<pre>
<code class="x-javascript">
'use strict';
var arr = ['Bart', 'Lisa', 'Adam'];
----
</code>
</pre>
<p>请尝试<code>for</code>循环和<code>while</code>循环，并以正序、倒序两种方式遍历。</p>
<h4 id="-">小结</h4>
<p>循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。</p>
<p>在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意<code>i &lt; 100</code>和<code>i &lt;= 100</code>是不同的判断逻辑。</p>
<h2>Map和Set</h2>
<p>JavaScript的默认对象表示方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：</p>
<pre>
<code class="x-javascript">
'use strict';
var m = new Map();
var s = new Set();
alert('你的浏览器支持Map和Set！');
----
// 直接运行测试
</code>
</pre>
<h4 id="map">Map</h4>
<p><code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<pre><code>var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];
</code></pre>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<pre><code>var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
</code></pre>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<pre><code>var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
</code></pre>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<pre><code>var m = new Map();
m.set('Adam', 67);
m.set('Adam', 88);
m.get('Adam'); // 88
</code></pre>
<h4 id="set">Set</h4>
<p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<pre><code>var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
</code></pre>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<pre><code>var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}
</code></pre>
<p>注意数字<code>3</code>和字符串<code>'3'</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<pre><code>&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; s
{1, 2, 3, 4}
</code></pre>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<pre><code>var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}
</code></pre>
<h4 id="-">小结</h4>
<p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<h2>iterable</h2>
<p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p><code>for ... of</code>循环是ES6引入的新的语法，请测试你的浏览器是否支持：</p>
<pre>
<code class="x-javascript">
'use strict';
var a = [1, 2, 3];
for (var x of a) {
}
alert('你的浏览器支持for ... of');
----
// 请直接运行测试
</code>
</pre>
<p>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<pre><code>var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    alert(x);
}
for (var x of s) { // 遍历Set
    alert(x);
}
for (var x of m) { // 遍历Map
    alert(x[0] + '=' + x[1]);
}
</code></pre>
<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</p>
<p><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个<code>Array</code>数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<pre><code>var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x in a) {
    alert(x); // '0', '1', '2', 'name'
}
</code></pre>
<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<pre><code>var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    alert(x); 'A', 'B', 'C'
}
</code></pre>
<p>这就是为什么要引入新的<code>for ... of</code>循环。</p>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<pre><code>var a = ['A', 'B', 'C'];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    alert(element);
});
</code></pre>
<p><em>注意</em>，<code>forEach()</code>方法是ES5.1标准引入的，你需要测试浏览器是否支持。</p>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<pre><code>var s = new Set(['A', 'B', 'C']);
s.forEach(function (element, sameElement, set) {
    alert(element);
});
</code></pre>
<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<pre><code>var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
m.forEach(function (value, key, map) {
    alert(value);
});
</code></pre>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<pre><code>var a = ['A', 'B', 'C'];
a.forEach(function (element) {
    alert(element);
});
</code></pre>
<h1>函数</h1>
<p>我们知道圆的面积计算公式为：</p>
<p>S = πr<sup>2</sup></p>
<p>当我们知道半径<code>r</code>的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<pre><code>var r1 = 12.34;
var r2 = 9.08;
var r3 = 73.1;
var s1 = 3.14 * r1 * r1;
var s2 = 3.14 * r2 * r2;
var s3 = 3.14 * r3 * r3;
</code></pre>
<p>当代码出现有规律的重复的时候，你就需要当心了，每次写<code>3.14 * x * x</code>不仅很麻烦，而且，如果要把<code>3.14</code>改成<code>3.14159265359</code>的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写<code>s = 3.14 * x * x</code>，而是写成更有意义的函数调用<code>s = area_of_circle(x)</code>，而函数<code>area_of_circle</code>本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。</p>
<h4 id="-">抽象</h4>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：<code>1 + 2 + 3 + ... + 100</code>，写起来十分不方便，于是数学家发明了求和符号∑，可以把<code>1 + 2 + 3 + ... + 100</code>记作：</p>
<p>100</p>
<p><span style="font-size:3em">∑</span><span style="font-size:2em">n</span></p>
<p>n=1</p>
<p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<p>100</p>
<p><span style="font-size:3em">∑</span><span style="font-size:2em">(n<sup>2</sup>+1)</span></p>
<p>n=1</p>
<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)</p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<h2>函数定义和调用</h2>
<h4 id="-">定义函数</h4>
<p>在JavaScript中，定义函数的方式如下：</p>
<pre><code>function abs(x) {
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
}
</code></pre>
<p>上述<code>abs()</code>函数的定义如下：</p>
<ul>
<li><code>function</code>指出这是一个函数定义；</li>
<li><code>abs</code>是函数的名称；</li>
<li><code>(x)</code>括号内列出函数的参数，多个参数以<code>,</code>分隔；</li>
<li><code>{ ... }</code>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ul>
<p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>undefined</code>。</p>
<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>
<p>因此，第二种定义函数的方式如下：</p>
<pre><code>var abs = function (x) {
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
};
</code></pre>
<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>
<p>上述两种定义<em>完全等价</em>，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>
<h4 id="-">调用函数</h4>
<p>调用函数时，按顺序传入参数即可：</p>
<pre><code>abs(10); // 返回10
abs(-9); // 返回9
</code></pre>
<p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<pre><code>abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
</code></pre>
<p>传入的参数比定义的少也没有问题：</p>
<pre><code>abs(); // 返回NaN
</code></pre>
<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>
<p>要避免收到<code>undefined</code>，可以对参数进行检查：</p>
<pre><code>function abs(x) {
    if (typeof x !== 'number') {
        throw 'Not a number';
    }
    if (x &gt;= 0) {
        return x;
    } else {
        return -x;
    }
}
</code></pre>
<h4 id="arguments">arguments</h4>
<p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：</p>
<pre><code>function foo(x) {
    alert(x); // 10
    for (var i=0; i&lt;arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
</code></pre>
<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
<pre><code>function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x &gt;= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9
</code></pre>
<p>实际上<code>arguments</code>最常用于判断传入参数的个数。你可能会看到这样的写法：</p>
<pre><code>// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
</code></pre>
<p>要把中间的参数<code>b</code>变为“可选”参数，就只能通过<code>arguments</code>判断，然后重新调整参数并赋值。</p>
<h4 id="rest-">rest参数</h4>
<p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数：</p>
<pre><code>function foo(a, b) {
    var i, rest = [];
    if (arguments.length &gt; 2) {
        for (i = 2; i&lt;arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}
</code></pre>
<p>为了获取除了已定义参数<code>a</code>、<code>b</code>之外的参数，我们不得不用<code>arguments</code>，并且循环要从索引<code>2</code>开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的<code>rest</code>参数，有没有更好的方法？</p>
<p>ES6标准引入了rest参数，上面的函数可以改写为：</p>
<pre><code>function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
</code></pre>
<p>rest参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是<code>undefined</code>）。</p>
<p>因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个<code>sum()</code>函数，接收任意个参数并返回它们的和：</p>
<pre>
<code class="x-javascript">
'use strict';
----
function sum(...rest) {
   ???
}
----
// 测试:
var i, args = [];
for (i=1; i&lt;=100; i++) {
    args.push(i);
}
if (sum() !== 0) {
    alert('测试失败: sum() = ' + sum());
} else if (sum(1) !== 1) {
    alert('测试失败: sum(1) = ' + sum(1));
} else if (sum(2, 3) !== 5) {
    alert('测试失败: sum(2, 3) = ' + sum(2, 3));
} else if (sum.apply(null, args) !== 5050) {
    alert('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));
} else {
    alert('测试通过!');
}
</code>
</pre>
<h4 id="-return-">小心你的return语句</h4>
<p>前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
<pre><code>function foo() {
    return { name: 'foo' };
}

foo(); // { name: 'foo' }
</code></pre>
<p>如果把return语句拆成两行：</p>
<pre><code>function foo() {
    return
        { name: 'foo' };
}

foo(); // undefined
</code></pre>
<p><em>要小心了</em>，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：</p>
<pre><code>function foo() {
    return; // 自动添加了分号，相当于return undefined;
        { name: 'foo' }; // 这行语句已经没法执行到了
}
</code></pre>
<p>所以正确的多行写法是：</p>
<pre><code>function foo() {
    return { // 这里不会自动加分号，因为{表示语句尚未结束
        name: 'foo'
    };
}
</code></pre>
<h4 id="-">练习</h4>
<p>定义一个计算圆面积的函数<code>area_of_circle()</code>，它有两个参数：</p>
<ul>
<li>r: 表示圆的半径；</li>
<li>pi: 表示π的值，如果不传，则默认3.14</li>
</ul>
<pre>
<code class="x-javascript">
'use strict';

function area_of_circle(r, pi) {
----
    return 0;
----
}
// 测试:
if (area_of_circle(2) === 12.56 &amp;&amp; area_of_circle(2, 3.1416) === 12.5664) {
    alert('测试通过');
} else {
    alert('测试失败');
}
</code>
</pre>
<p>Max是一个JavaScript新手，他写了一个<code>max()</code>函数，返回两个数中较大的那个：</p>
<pre>
<code class="x-javascript">
'use strict';

function max(a, b) {
----
    if (a &gt; b) {
        return
                a;
    } else {
        return
                b;
    }
----
}
alert(max(15, 20));
</code>
</pre>
<p>但是Max抱怨他的浏览器出问题了，无论传入什么数，<code>max()</code>函数总是返回<code>undefined</code>。请帮他指出问题并修复。</p>
<h2>变量作用域</h2>
<p>在JavaScript中，用<code>var</code>申明的变量实际上是有作用域的。</p>
<p>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：</p>
<pre><code>'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x
</code></pre>
<p>如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：</p>
<pre><code>'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

function bar() {
    var x = 'A';
    x = x + 'B';
}
</code></pre>
<p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</p>
<pre><code>'use strict';

function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}
</code></pre>
<p>如果内部函数和外部函数的变量名重名怎么办？</p>
<pre><code>'use strict';

function foo() {
    var x = 1;
    function bar() {
        var x = 'A';
        alert('x in bar() = ' + x); // 'A'
    }
    alert('x in foo() = ' + x); // 1
    bar();
}
</code></pre>
<p>这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</p>
<h4 id="-">变量提升</h4>
<p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
<pre><code>'use strict';

function foo() {
    var x = 'Hello, ' + y;
    alert(x);
    var y = 'Bob';
}

foo();
</code></pre>
<p>虽然是strict模式，但语句<code>var x = 'Hello, ' + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>
<p>对于上述<code>foo()</code>函数，JavaScript引擎看到的代码相当于：</p>
<pre><code>function foo() {
    var y; // 提升变量y的申明
    var x = 'Hello, ' + y;
    alert(x);
    y = 'Bob';
}
</code></pre>
<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个<code>var</code>申明函数内部用到的所有变量：</p>
<pre><code>function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i&lt;100; i++) {
        ...
    }
}
</code></pre>
<h4 id="-">全局作用域</h4>
<p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被绑定到<code>window</code>的一个属性：</p>
<pre><code>'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
</code></pre>
<p>因此，直接访问全局变量<code>course</code>和访问<code>window.course</code>是完全一样的。</p>
<p>你可能猜到了，由于函数定义有两种方式，以变量方式<code>var foo = function () {}</code>定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到<code>window</code>对象：</p>
<pre><code>'use strict';

function foo() {
    alert('foo');
}

foo(); // 直接调用foo()
window.foo(); // 通过window.foo()调用
</code></pre>
<p>进一步大胆地猜测，我们每次直接调用的<code>alert()</code>函数其实也是<code>window</code>的一个变量：</p>
<pre>
<code class="x-javascript">
'use strict';

window.alert('调用window.alert()');
// 把alert保存到另一个变量:
var old_alert = window.alert;
// 给alert赋一个新函数:
window.alert = function () {}
----
alert('无法用alert()显示了!');
----
// 恢复alert:
window.alert = old_alert;
alert('又可以用alert()了!');
</code>
</pre>
<p>这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</p>
<h4 id="-">名字空间</h4>
<p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<pre><code>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
</code></pre>
<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。</p>
<p>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
<h4 id="-">局部作用域</h4>
<p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的：</p>
<pre><code>'use strict';

function foo() {
    for (var i=0; i&lt;100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
</code></pre>
<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p>
<pre><code>'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i&lt;100; i++) {
        sum += i;
    }
    i += 1; // SyntaxError
}
</code></pre>
<h4 id="-">常量</h4>
<p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
<pre><code>var PI = 3.14;
</code></pre>
<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<pre><code>'use strict';

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
</code></pre>
<h2>方法</h2>
<p>在一个对象中绑定函数，称为这个对象的方法。</p>
<p>在JavaScript中，对象的定义是这样的：</p>
<pre><code>var xiaoming = {
    name: '小明',
    birth: 1990
};
</code></pre>
<p>但是，如果我们给<code>xiaoming</code>绑定一个函数，就可以做更多的事情。比如，写个<code>age()</code>方法，返回<code>xiaoming</code>的年龄：</p>
<pre><code>var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
</code></pre>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字，这个东东是什么？</p>
<p>在一个方法内部，<code>this</code>是一个特殊变量，它始终指向当前对象，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>
<p>让我们拆开写：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
</code></pre>
<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？<em>请注意</em>，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。</p>
<p>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<pre><code>var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
</code></pre>
<p>也是不行的！要保证<code>this</code>指向正确，必须用<code>obj.xxx()</code>的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的<code>this</code>指向<code>undefined</code>，因此，在strict模式下，你会得到一个错误：</p>
<pre><code>'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
</code></pre>
<p>这个决定只是让错误及时暴露出来，并没有解决<code>this</code>应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<pre><code>'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
</code></pre>
<p>结果又报错了！原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！（在非strict模式下，它重新指向全局对象<code>window</code>！）</p>
<p>修复的办法也不是没有，我们用一个<code>that</code>变量首先捕获<code>this</code>：</p>
<pre><code>'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
</code></pre>
<p>用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h4 id="apply">apply</h4>
<p>虽然在一个独立的函数调用中，根据是否是strict模式，<code>this</code>指向<code>undefined</code>或<code>window</code>，不过，我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre>
<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><p><code>apply()</code>把参数打包成<code>Array</code>再传入；</p>
</li>
<li><p><code>call()</code>把参数按顺序传入。</p>
</li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<pre><code>Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
</code></pre>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<h4 id="-">装饰器</h4>
<p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：</p>
<pre><code>var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试:
parseInt('10');
parseInt('20');
parseInt('30');
count; // 3
</code></pre>
<h2>高阶函数</h2>
<p>高阶函数英文叫Higher-order function。那么什么是高阶函数？</p>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<pre><code>function add(x, y, f) {
    return f(x) + f(y);
}
</code></pre>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<pre><code>x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;
return 11;
</code></pre>
<p>用代码验证一下：</p>
<pre><code>add(-5, 6, Math.abs); // 11
</code></pre>
<p>编写高阶函数，就是让函数的参数能够接收别的函数。</p>
<h3>map/reduce</h3>
<p>如果你读过Google的那篇大名鼎鼎的论文“<a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a>”，你就能大概明白map/reduce的概念。</p>
<h4 id="map">map</h4>
<p>举例说明，比如我们有一个函数f(x)=x<sup>2</sup>，要把这个函数作用在一个数组<code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map</code>实现如下：</p>
<p><img src="files/attachments/0013879622109990efbf9d781704b02994ba96765595f56000.png" alt="map"></p>
<p>由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
<pre><code>function pow(x) {
    return x * x;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p><code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。</p>
<p>你可能会想，不需要<code>map()</code>，写一个循环，也可以计算出结果：</p>
<pre><code>var f = function (x) {
    return x * x;
};

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var result = [];
for (var i=0; i&lt;arr.length; i++) {
    result.push(f(arr[i]));
}
</code></pre>
<p>的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。</p>
<p>所以，<code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x<sup>2</sup>，还可以计算任意复杂的函数，比如，把<code>Array</code>的所有数字转为字符串：</p>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
</code></pre>
<p>只需要一行代码。</p>
<h4 id="reduce">reduce</h4>
<p>再看reduce的用法。Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个<code>Array</code>求和，就可以用<code>reduce</code>实现：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25
</code></pre>
<p>练习：利用<code>reduce()</code>求积：</p>
<pre>
<code class="x-javascript">
'use strict';

function product(arr) {
----
    return 0;
----
}

// 测试:
if (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) {
    alert('测试通过!');
}
else {
    alert('测试失败!');
}
</code>
</pre>
<p>要把<code>[1, 3, 5, 7, 9]</code>变换成整数13579，<code>reduce()</code>也能派上用场：</p>
<pre><code>var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579
</code></pre>
<p>如果我们继续改进这个例子，想办法把一个字符串<code>13579</code>先变成<code>Array</code>——<code>[1, 3, 5, 7, 9]</code>，再利用<code>reduce()</code>就可以写出一个把字符串转换为Number的函数。</p>
<p>练习：不要使用JavaScript内置的<code>parseInt()</code>函数，利用map和reduce操作实现一个<code>string2int()</code>函数：</p>
<pre>
<code class="x-javascript">
'use strict';

function string2int(s) {
----
    return 0;
----
}

// 测试:
if (string2int('0') === 0 &amp;&amp; string2int('12345') === 12345 &amp;&amp; string2int('12300') === 12300) {
    if (string2int.toString().indexOf('parseInt') !== -1) {
        alert('请勿使用parseInt()!');
    } else if (string2int.toString().indexOf('Number') !== -1) {
        alert('请勿使用Number()!');
    } else {
        alert('测试通过!');
    }
}
else {
    alert('测试失败!');
}
</code>
</pre>
<h4 id="-">练习</h4>
<p>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：<code>['adam', 'LISA', 'barT']</code>，输出：<code>['Adam', 'Lisa', 'Bart']</code>。</p>
<pre>
<code class="x-javascript">
'use strict';

function normalize(arr) {
----
    return [];
----
}

// 测试:
if (normalize(['adam', 'LISA', 'barT']).toString() === ['Adam', 'Lisa', 'Bart'].toString()) {
    alert('测试通过!');
}
else {
    alert('测试失败!');
}
</code>
</pre>
<p>小明希望利用<code>map()</code>把字符串变成整数，他写的代码很简洁：</p>
<pre>
<code class="x-javascript">
'use strict';

var arr = ['1', '2', '3'];
var r;
----
r = arr.map(parseInt);
----
alert('[' + r[0] + ', ' + r[1] + ', ' + r[2] + ']');
</code>
</pre>
<p>结果竟然是<code>[1, NaN, NaN]</code>，小明百思不得其解，请帮他找到原因并修正代码。</p>
<p>提示：参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()的文档</a>。</p>
<p><button id="x-why-parseInt-failed" class="uk-button uk-button-success">原因分析</button></p>
<div id="x-answer-parseInt-failed" style="display:none;">
<p>由于<code>map()</code>接收的回调函数可以有3个参数：<code>callback(currentValue, index, array)</code>，通常我们仅需要第一个参数，而忽略了传入的后面两个参数。不幸的是，<code>parseInt(string, radix)</code>没有忽略第二个参数，导致实际执行的函数分别是：</p>
<ul>
<li><p>parseInt('0', 0); // 0, 按十进制转换</p></li>
<li><p>parseInt('1', 1); // NaN, 没有一进制</p></li>
<li><p>parseInt('2', 2); // NaN, 按二进制转换不允许出现2</p></li>
</ul>
<p>可以改为<code>r = arr.map(Number);</code>，因为<code>Number(value)</code>函数仅接收一个参数。</p>
</div>
<script>
$(function () {
    $('#x-why-parseInt-failed').click(function () {
        var btn = $(this);
        btn.attr('disabled', 'disabled');
        btn.text('请先思考60秒...');
        setTimeout(function () {
            $('#x-why-parseInt-failed').hide();
            $('#x-answer-parseInt-failed').show();
        }, 60000);
    });
});
</script>
<h3>filter</h3>
<p>filter也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：</p>
<pre><code>var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
</code></pre>
<p>把一个<code>Array</code>中的空字符串删掉，可以这么写：</p>
<pre><code>var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
</code></pre>
<p>可见用<code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<h4 id="-">练习</h4>
<p>请尝试用<code>filter()</code>筛选出素数：</p>
<pre>
<code class="x-javascript">
'use strict';

function get_primes(arr) {
----
    return [];
----
}

// 测试:
var
    x,
    r,
    arr = [];
for (x = 1; x &lt; 100; x++) {
    arr.push(x);
}
r = get_primes(arr);
if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) {
    alert('测试通过!');
} else {
    alert('测试失败: ' + r.toString());
}
</code>
</pre>
<h3>sort</h3>
<h4 id="-">排序算法</h4>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素<code>x</code>和<code>y</code>，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但是排序结果可能让你大吃一惊：</p>
<pre><code>// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
</code></pre>
<p>第二个排序把<code>apple</code>排在了最后，是因为字符串根据ASCII码进行排序，而小写字母<code>a</code>的ASCII码在大写字母之后。</p>
<p>第三个排序结果是什么鬼？简单的数字排序都能错？</p>
<p>这是因为<code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序，结果<code>'10'</code>排在了<code>'2'</code>的前面，因为字符<code>'1'</code>比字符<code>'2'</code>的ASCII码小。</p>
<p><img src="files/attachments/0014404661280028775b0bde3a649eca7652c9863e5ba1e000.png" alt="douwo"></p>
<p>如果不知道<code>sort()</code>方法的默认排序规则，直接对数字排序，绝对栽进坑里！</p>
<p>幸运的是，<code>sort()</code>方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，我们可以这么写：</p>
<pre><code>var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return -1;
    }
    if (x &gt; y) {
        return 1;
    }
    return 0;
}); // [1, 2, 10, 20]
</code></pre>
<p>如果要倒序排序，我们可以把大的数放前面：</p>
<pre><code>var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x &lt; y) {
        return 1;
    }
    if (x &gt; y) {
        return -1;
    }
    return 0;
}); // [20, 10, 2, 1]
</code></pre>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p>
<pre><code>var arr = ['Google', 'apple', 'Microsoft'];
arr.sort(function (s1, s2) {
    x1 = s1.toUpperCase();
    x2 = s2.toUpperCase();
    if (x1 &lt; x2) {
        return -1;
    }
    if (x1 &gt; x2) {
        return 1;
    }
    return 0;
}); // ['apple', 'Google', 'Microsoft']
</code></pre>
<p>忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<p>最后友情提示，<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code>：</p>
<pre><code>var a1 = ['B', 'A', 'C'];
var a2 = a1.sort();
a1; // ['A', 'B', 'C']
a2; // ['A', 'B', 'C']
a1 === a2; // true, a1和a2是同一对象
</code></pre>
<h2>闭包</h2>
<h4 id="-">函数作为返回值</h4>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个对<code>Array</code>的求和。通常情况下，求和的函数是这样定义的：</p>
<pre><code>function sum(arr) {
    return arr.reduce(function (x, y) {
        return x + y;
    });
}

sum([1, 2, 3, 4, 5]); // 15
</code></pre>
<p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！</p>
<pre><code>function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
</code></pre>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code>var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code>f(); // 15
</code></pre>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
<pre><code>var f1 = lazy_sum([1, 2, 3, 4, 5]);
var f2 = lazy_sum([1, 2, 3, 4, 5]);
f1 === f2; // false
</code></pre>
<p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
<h4 id="-">闭包</h4>
<p>注意到返回的函数在其定义内部引用了局部变量<code>arr</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。我们来看一个例子：</p>
<pre><code>function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个<code>Array</code>中返回了。</p>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p>
<pre><code>f1(); // 16
f2(); // 16
f3(); // 16
</code></pre>
<p>全部都是<code>16</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>4</code>，因此最终结果为<code>16</code>。</p>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code>function count() {
    var arr = [];
    for (var i=1; i&lt;=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9
</code></pre>
<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
<pre><code>(function (x) {
    return x * x;
})(3); // 9
</code></pre>
<p>理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
<pre><code>function (x) { return x * x } (3);
</code></pre>
<p>但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：</p>
<pre><code>(function (x) { return x * x }) (3);
</code></pre>
<p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：</p>
<pre><code>(function (x) {
    return x * x;
})(3);
</code></pre>
<p>说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？</p>
<p>当然不是！闭包有非常强大的功能。举个栗子：</p>
<p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用<code>private</code>修饰一个成员变量。</p>
<p>在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<pre><code>'use strict';

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
</code></pre>
<p>它用起来像这样：</p>
<pre><code>var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
</code></pre>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量<code>x</code>，并且，从外部代码根本无法访问到变量<code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算x<sup>y</sup>可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x<sup>2</sup>或x<sup>3</sup>，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
<pre><code>function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}

// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);

pow2(5); // 25
pow3(7); // 343
</code></pre>
<h4 id="-">脑洞大开</h4>
<p>很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>这些数字和<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>这些符号。</p>
<p>JavaScript支持函数，所以可以用JavaScript用函数来写这些计算。来试试：</p>
<pre>
<code class="x-javascript">
'use strict';

// 定义数字0:
var zero = function (f) {
    return function (x) {
        return x;
    }
};

// 定义数字1:
var one = function (f) {
    return function (x) {
        return f(x);
    }
};

// 定义加法:
function add(n, m) {
    return function (f) {
        return function (x) {
            return m(f)(n(f)(x));
        }
    }
}
----
// 计算数字2 = 1 + 1:
var two = add(one, one);

// 计算数字3 = 1 + 2:
var three = add(one, two);

// 计算数字5 = 2 + 3:
var five = add(two, three);

// 你说它是3就是3，你说它是5就是5，你怎么证明？

// 呵呵，看这里:

// 给3传一个函数,会打印3次:
(three(function () {
    console.log('print 3 times');
}))();

// 给5传一个函数,会打印5次:
(five(function () {
    console.log('print 5 times');
}))();

// 继续接着玩一会...
</code>
</pre>
<h2>箭头函数</h2>
<p>ES6标准新增了一种新的函数：Arraw Function（箭头函数）。</p>
<p>为什么叫Arrow Function？因为它的定义用的就是一个箭头：</p>
<pre><code>x =&gt; x * x
</code></pre>
<p>上面的箭头函数相当于：</p>
<pre><code>function (x) {
    return x * x;
}
</code></pre>
<p>在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Array Function：</p>
<pre>
<code class="x-javascript">
'use strict';
----
var fn = x =&gt; x * x;
----
alert('你的浏览器支持ES6的Array Function!');
</code>
</pre>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：</p>
<pre><code>x =&gt; {
    if (x &gt; 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
</code></pre>
<p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<pre><code>// 两个参数:
(x, y) =&gt; x * x + y * y

// 无参数:
() =&gt; 3.14

// 可变参数:
(x, y, ...rest) =&gt; {
    var i, sum = x + y;
    for (i=0; i&lt;rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
</code></pre>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<pre><code>// SyntaxError:
x =&gt; { foo: x }
</code></pre>
<p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p>
<pre><code>// ok:
x =&gt; ({ foo: x })
</code></pre>
<h4 id="this">this</h4>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
</code></pre>
<p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
</code></pre>
<p>如果使用箭头函数，以前的那种hack写法：</p>
<pre><code>var that = this;
</code></pre>
<p>就不再需要了。</p>
<p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略：</p>
<pre><code>var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) =&gt; y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
</code></pre>
<h2>generator</h2>
<p>generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</p>
<p>ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000">Python教程</a>！。</p>
<p>我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：</p>
<pre><code>function foo(x) {
    return x + x;
}

var r = foo(1); // 调用foo函数
</code></pre>
<p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p>
<p>generator跟函数很像，定义如下：</p>
<pre><code>function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
</code></pre>
<p>generator和函数不同的是，generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。</p>
<p>大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？</p>
<p>还是举个栗子吧。</p>
<p>我们以一个著名的斐波那契数列为例，它由<code>0</code>，<code>1</code>开头：</p>
<pre><code>0 1 1 2 3 5 8 13 21 34 ...
</code></pre>
<p>要编写一个产生斐波那契数列的函数，可以这么写：</p>
<pre><code>function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length &lt; max) {
        t = a + b;
        a = b;
        b = t;
        arr.push(t);
    }
    return arr;
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
</code></pre>
<p>函数只能返回一次，所以必须返回一个<code>Array</code>。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：</p>
<pre><code>function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 1;
    while (n &lt; max) {
        yield a;
        t = a + b;
        a = b;
        b = t;
        n ++;
    }
    return a;
}
</code></pre>
<p>直接调用试试：</p>
<pre><code>fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
</code></pre>
<p>直接调用一个generator和调用函数不一样，<code>fib(5)</code>仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：</p>
<pre><code>var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: true}
</code></pre>
<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>
<p>当执行到<code>done</code>为<code>true</code>时，这个generator对象就已经全部执行完毕，不要再继续调用<code>next()</code>了。</p>
<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：</p>
<pre><code>for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
</code></pre>
<p>generator和普通函数相比，有什么用？</p>
<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：</p>
<pre><code>var fib = {
    a: 0,
    b: 1,
    n: 0,
    max: 5,
    next: function () {
        var
            r = this.a,
            t = this.a + this.b;
        this.a = this.b;
        this.b = t;
        if (this.n &lt; this.max) {
            this.n ++;
            return r;
        } else {
            return undefined;
        }
    }
};
</code></pre>
<p>用对象的属性来保存状态，相当繁琐。</p>
<p>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。</p>
<p>没有generator之前的黑暗时代，用AJAX时需要这么写代码：</p>
<pre><code>ajax('http://url-1', data1, function (err, result) {
    if (err) {
        return handle(err);
    }
    ajax('http://url-2', data2, function (err, result) {
        if (err) {
            return handle(err);
        }
        ajax('http://url-3', data3, function (err, result) {
            if (err) {
                return handle(err);
            }
            return success(result);
        });
    });
});
</code></pre>
<p>回调越多，代码越难看。</p>
<p>有了generator的美好时代，用AJAX时可以这么写：</p>
<pre><code>try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}
</code></pre>
<p>看上去是同步的代码，实际执行是异步的。</p>
<h4 id="-">练习</h4>
<p>要生成一个自增的ID，可以编写一个<code>next_id()</code>函数：</p>
<pre><code>var current_id = 0;

function next_id() {
    current_id ++;
    return current_id;
}
</code></pre>
<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。</p>
<p>不用闭包，试用generator改写：</p>
<pre>
<code class="x-javascript">
'use strict';
function* next_id() {
----
----
}

// 测试:
var
    x,
    pass = true,
    g = next_id();
for (x = 1; x &lt; 100; x ++) {
    if (g.next().value !== x) {
        pass = false;
        alert('测试失败!');
        break;
    }
}
if (pass) {
    alert('测试通过!');
}
</code>
</pre>
<h1>标准对象</h1>
<p>在JavaScript的世界里，一切都是对象。</p>
<p>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用<code>typeof</code>操作符获取对象的类型，它总是返回一个字符串：</p>
<pre><code>typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object'
typeof []; // 'object'
typeof {}; // 'object'
</code></pre>
<p>可见，<code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。特别注意<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>{}</code>。</p>
<h4 id="-">包装对象</h4>
<p>除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚<code>int</code>和<code>Integer</code>这种暧昧关系。</p>
<p><code>number</code>、<code>boolean</code>和<code>string</code>都有包装对象。没错，在JavaScript中，字符串也区分<code>string</code>类型和它的包装类型。包装对象用<code>new</code>创建：</p>
<pre><code>var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String('str'); // 'str',生成了新的包装类型
</code></pre>
<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为<code>object</code>了！所以，包装对象和原始值用<code>===</code>比较会返回<code>false</code>：</p>
<pre><code>typeof new Number(123); // 'object'
new Number(123) === 123; // false

typeof new Boolean(true); // 'object'
new Boolean(true) === true; // false

typeof new String('str'); // 'object'
new String('str') === 'str'; // false
</code></pre>
<p>所以<em>闲的蛋疼也不要使用包装对象</em>！尤其是针对<code>string</code>类型！！！</p>
<p>如果我们在使用<code>Number</code>、<code>Boolean</code>和<code>String</code>时，没有写<code>new</code>会发生什么情况？</p>
<p>此时，<code>Number()</code>、<code>Boolean</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）：</p>
<pre><code>var n = Number('123'); // 123，相当于parseInt()或parseFloat()
typeof n; // 'number'

var b = Boolean('true'); // true
typeof b; // 'boolean'

var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(''); // false

var s = String(123.45); // '123.45'
typeof s; // 'string'
</code></pre>
<p>是不是感觉头大了？这就是JavaScript特有的催眠魅力！</p>
<p>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p>
</li>
<li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p>
</li>
<li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p>
</li>
<li><p>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</p>
</li>
<li><p><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</p>
</li>
<li><p>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</p>
</li>
<li><p>判断<code>null</code>请使用<code>myVar === null</code>；</p>
</li>
<li><p>判断某个全局变量是否存在用<code>typeof window.myVar === 'undefined'</code>；</p>
</li>
<li><p>函数内部判断某个变量是否存在用<code>typeof myVar === 'undefined'</code>。</p>
</li>
</ul>
<p>最后有细心的同学指出，任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p>
<p>更细心的同学指出，<code>number</code>对象调用<code>toString()</code>报SyntaxError：</p>
<pre><code>123.toString(); // SyntaxError
</code></pre>
<p>遇到这种情况，要特殊处理一下：</p>
<pre><code>123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
</code></pre>
<p>不要问为什么，这就是JavaScript代码的乐趣！</p>
<h2>Date</h2>
<p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用：</p>
<pre><code>var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
</code></pre>
<p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p>
<p>如果要创建一个指定日期和时间的<code>Date</code>对象，可以用：</p>
<pre><code>var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
</code></pre>
<p>你可能观察到了一个<em>非常非常坑爹</em>的地方，就是JavaScript的月份范围用整数表示是0~11，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示6月，我们传入的是<code>5</code>！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。</p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合<a href="http://www.w3.org/TR/NOTE-datetime">ISO 8601</a>格式的字符串：</p>
<pre><code>var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 1435146562875
</code></pre>
<p>但它返回的不是<code>Date</code>对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：</p>
<pre><code>var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
</code></pre>
<h4 id="-">时区</h4>
<p><code>Date</code>对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：</p>
<pre><code>var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
</code></pre>
<p>那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个<code>number</code>类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。</p>
<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>
<p>所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。</p>
<p>要获取当前时间戳，可以用：</p>
<pre><code>if (Date.now) {
    alert(Date.now()); // 老版本IE没有now()方法
} else {
    alert(new Date().getTime());
}
</code></pre>
<h4 id="-">练习</h4>
<p>小明为了和女友庆祝情人节，特意制作了网页，并提前预定了法式餐厅。小明打算用JavaScript给女友一个惊喜留言：</p>
<pre>
<code class="x-javascript">
'use strict';
----
var today = new Date();
if (today.getMonth() === 2 &amp;&amp; today.getDate() === 14) {
    alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');
}
</code>
</pre>
<p>结果女友并未出现。小明非常郁闷，请你帮忙分析他的JavaScript代码有何问题。</p>
<p><img src="files/attachments/00143514905461536b6ab3d25474b02b6648d4608f10cd7000.png" alt="注孤生"></p>
<h2>RegExp</h2>
<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取<code>@</code>前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>
<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<p>所以我们判断一个字符串是否是合法的Email的方法是：</p>
<ol>
<li><p>创建一个匹配Email的正则表达式；</p>
</li>
<li><p>用该正则表达式去匹配用户的输入来判断是否合法。</p>
</li>
</ol>
<p>因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。</p>
<p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：</p>
<ul>
<li><p><code>'00\d'</code>可以匹配<code>'007'</code>，但无法匹配<code>'00A'</code>；</p>
</li>
<li><p><code>'\d\d\d'</code>可以匹配<code>'010'</code>；</p>
</li>
<li><p><code>'\w\w'</code>可以匹配<code>'js'</code>；</p>
</li>
</ul>
<p><code>.</code>可以匹配任意字符，所以：</p>
<ul>
<li><code>'js.'</code>可以匹配<code>'jsp'</code>、<code>'jss'</code>、<code>'js!'</code>等等。</li>
</ul>
<p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：</p>
<p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。</p>
<p>我们来从左到右解读一下：</p>
<ol>
<li><p><code>\d{3}</code>表示匹配3个数字，例如<code>'010'</code>；</p>
</li>
<li><p><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code>，<code>'\t\t'</code>等；</p>
</li>
<li><p><code>\d{3,8}</code>表示3-8个数字，例如<code>'1234567'</code>。</p>
</li>
</ol>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配<code>'010-12345'</code>这样的号码呢？由于<code>'-'</code>是特殊字符，在正则表达式中，要用<code>'\'</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>
<p>但是，仍然无法匹配<code>'010 - 12345'</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p>
<h4 id="-">进阶</h4>
<p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>
<ul>
<li><p><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</p>
</li>
<li><p><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'js2015'</code>等等；</p>
</li>
<li><p><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</p>
</li>
<li><p><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p>
</li>
</ul>
<p><code>A|B</code>可以匹配A或B，所以<code>[J|j]ava[S|s]cript</code>可以匹配<code>'JavaScript'</code>、<code>'Javascript'</code>、<code>'javaScript'</code>或者<code>'javascript'</code>。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>你可能注意到了，<code>js</code>也可以匹配<code>'jsp'</code>，但是加上<code>^js$</code>就变成了整行匹配，就只能匹配<code>'js'</code>了。</p>
<h4 id="regexp">RegExp</h4>
<p>有了准备知识，我们就可以在JavaScript中使用正则表达式了。</p>
<p>JavaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp('正则表达式')</code>创建一个RegExp对象。</p>
<p>两种写法是一样的：</p>
<pre><code>var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
</code></pre>
<p>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个<code>\\</code>实际上是一个<code>\</code>。</p>
<p>先看看如何判断正则表达式是否匹配：</p>
<pre><code>var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
</code></pre>
<p>RegExp对象的<code>test()</code>方法用于测试给定的字符串是否符合条件。</p>
<h4 id="-">切分字符串</h4>
<p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<pre><code>'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
</code></pre>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<pre><code>'a b   c'.split(/\s+/); // ['a', 'b', 'c']
</code></pre>
<p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<pre><code>'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
</code></pre>
<p>再加入<code>;</code>试试：</p>
<pre><code>'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
</code></pre>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h4 id="-">分组</h4>
<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<pre><code>var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
</code></pre>
<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<pre><code>var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
</code></pre>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<pre><code>var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
</code></pre>
<p>对于<code>'2-30'</code>，<code>'4-31'</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h4 id="-">贪婪匹配</h4>
<p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<pre><code>var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
</code></pre>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<pre><code>var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
</code></pre>
<h4 id="-">全局搜索</h4>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p>
<pre><code>var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
</code></pre>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<pre><code>var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
</code></pre>
<p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>
<h4 id="-">小结</h4>
<p>正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。</p>
<h4 id="-">练习</h4>
<p>请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：</p>
<pre>
<code class="x-javascript">
'use strict';
----
var re = /^$/;
----
// 测试:
var
    i,
    success = true,
    should_pass = ['someone@gmail.com', 'bill.gates@microsoft.com', 'tom@voyager.org', 'bob2015@163.com'],
    should_fail = ['test#gmail.com', 'bill@microsoft', 'bill%gates@ms.com', '@voyager.org'];
for (i = 0; i &lt; should_pass.length; i++) {
    if (!re.test(should_pass[i])) {
        alert('测试失败: ' + should_pass[i]);
        success = false;
        break;
    }
}
for (i = 0; i &lt; should_fail.length; i++) {
    if (re.test(should_fail[i])) {
        alert('测试失败: ' + should_fail[i]);
        success = false;
        break;
    }
}
if (success) {
    alert('测试通过!');
}
</code>
</pre>
<p>版本二可以验证并提取出带名字的Email地址：</p>
<pre class="x-javascript">
'use strict';
----
var re = /^$/;
----
// 测试:
var r = re.exec('&lt;Tom Paris&gt; tom@voyager.org');
if (r === null || r.toString() !== ['&lt;Tom Paris&gt; tom@voyager.org', 'Tom Paris', 'tom@voyager.org'].toString()) {
    alert('测试失败!');
}
else {
    alert('测试成功!');
}
</pre>
<h2>JSON</h2>
<p>JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。</p>
<p>在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。</p>
<p>终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。</p>
<p>道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>
<ul>
<li>number：和JavaScript的<code>number</code>完全一致；</li>
<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>
<li>string：就是JavaScript的<code>string</code>；</li>
<li>null：就是JavaScript的<code>null</code>；</li>
<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>
<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>
</ul>
<p>以及上面的任意组合。</p>
<p>并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号<code>""</code>，Object的键也必须用双引号<code>""</code>。</p>
<p>由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。</p>
<p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p>
<p>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p>
<h4 id="-">序列化</h4>
<p>让我们先把小明这个对象序列化成JSON格式的字符串：</p>
<pre><code>var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};

JSON.stringify(xiaoming); // '{"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}'
</code></pre>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<pre><code>JSON.stringify(xiaoming, null, '  ');
</code></pre>
<p>结果：</p>
<pre><code>{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" Middle School",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
</code></pre>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：</p>
<pre><code>JSON.stringify(xiaoming, ['name', 'skills'], '  ');
</code></pre>
<p>结果：</p>
<pre><code>{
  "name": "小明",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
</code></pre>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
<pre><code>function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, '  ');
</code></pre>
<p>上面的代码把所有属性值都变成大写：</p>
<pre><code>{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" MIDDLE SCHOOL",
  "skills": [
    "JAVASCRIPT",
    "JAVA",
    "PYTHON",
    "LISP"
  ]
}
</code></pre>
<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：</p>
<pre><code>var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};

JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
</code></pre>
<h4 id="-">反序列化</h4>
<p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p>
<pre><code>JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
</code></pre>
<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</p>
<pre><code>JSON.parse('{"name":"小明","age":14}', function (key, value) {
    // 把number * 2:
    if (key === 'name') {
        return value + '同学';
    }
    return value;
}); // Object {name: '小明同学', age: 14}
</code></pre>
<p>在JavaScript中使用JSON，就是这么简单！</p>
<h4 id="-">练习</h4>
<p>用浏览器访问Yahoo的<a href="https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json">天气API</a>，查看返回的JSON数据。</p>
<h1>面向对象编程</h1>
<p>JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？</p>
<p>当然不是。如果我们只使用<code>Number</code>、<code>Array</code>、<code>string</code>以及基本的<code>{...}</code>定义的对象，还无法发挥出面向对象编程的威力。</p>
<p>JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。如果你熟悉Java或C#，很好，你一定明白面向对象的两个基本概念：</p>
<ol>
<li><p>类：类是对象的类型模板，例如，定义<code>Student</code>类来表示学生，类本身是一种类型，<code>Student</code>表示学生类型，但不表示任何具体的某个学生；</p>
</li>
<li><p>实例：实例是根据类创建的对象，例如，根据<code>Student</code>类可以创建出<code>xiaoming</code>、<code>xiaohong</code>、<code>xiaojun</code>等多个实例，每个实例表示一个具体的学生，他们全都属于<code>Student</code>类型。</p>
</li>
</ol>
<p>所以，类和实例是大多数面向对象编程语言的基本概念。</p>
<p>不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>原型是指当我们想要创建<code>xiaoming</code>这个具体的学生时，我们并没有一个<code>Student</code>类型可用。那怎么办？恰好有这么一个现成的对象：</p>
<pre><code>var robot = {
    name: 'Robot',
    height: 1.6,
    run: function () {
        console.log(this.name + ' is running...');
    }
};
</code></pre>
<p>我们看这个<code>robot</code>对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！</p>
<p>于是我们把它改名为<code>Student</code>，然后创建出<code>xiaoming</code>：</p>
<pre><code>var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

var xiaoming = {
    name: '小明'
};

xiaoming.__proto__ = Student;
</code></pre>
<p>注意最后一行代码把<code>xiaoming</code>的原型指向了对象<code>Student</code>，看上去<code>xiaoming</code>仿佛是从<code>Student</code>继承下来的：</p>
<pre><code>xiaoming.name; // '小明'
xiaoming.run(); // 小明 is running...
</code></pre>
<p><code>xiaoming</code>有自己的<code>name</code>属性，但并没有定义<code>run()</code>方法。不过，由于小明是从<code>Student</code>继承而来，只要<code>Student</code>有<code>run()</code>方法，<code>xiaoming</code>也可以调用：</p>
<p><img src="files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000.png" alt="xiaoming-prototype"></p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>如果你把<code>xiaoming</code>的原型指向其他对象：</p>
<pre><code>var Bird = {
    fly: function () {
        console.log(this.name + ' is flying...');
    }
};

xiaoming.__proto__ = Bird;
</code></pre>
<p>现在<code>xiaoming</code>已经无法<code>run()</code>了，他已经变成了一只鸟：</p>
<pre><code>xiaoming.fly(); // 小明 is flying...
</code></pre>
<p>在JavaScrip代码运行时期，你可以把<code>xiaoming</code>从<code>Student</code>变成<code>Bird</code>，或者变成任何对象。</p>
<p><em>请注意</em>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建<code>xiaoming</code>：</p>
<pre><code>// 原型对象:
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent('小明');
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
</code></pre>
<p>这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象，我们在后面会一一讲到。</p>
<h2>创建对象</h2>
<p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</p>
<p>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>
<p>例如，创建一个<code>Array</code>对象：</p>
<pre><code>var arr = [1, 2, 3];
</code></pre>
<p>其原型链是：</p>
<pre><code>arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>
<p>当我们创建一个函数时：</p>
<pre><code>function foo() {
    return 0;
}
</code></pre>
<p>函数也是一个对象，它的原型链是：</p>
<pre><code>foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>
<p>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
<h4 id="-">构造函数</h4>
<p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<pre><code>function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
</code></pre>
<p>你会问，咦，这不是一个普通函数吗？</p>
<p>这确实是一个普通函数，但是在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：</p>
<pre><code>var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
</code></pre>
<p><em>注意</em>，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>
<p>新创建的<code>xiaoming</code>的原型链是：</p>
<pre><code>xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>也就是说，<code>xiaoming</code>的原型指向函数<code>Student</code>的原型。如果你又创建了<code>xiaohong</code>、<code>xiaojun</code>，那么这些对象的原型与<code>xiaoming</code>是一样的：</p>
<pre><code>xiaoming ↘
xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; null
xiaojun  ↗
</code></pre>
<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：</p>
<pre><code>xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
</code></pre>
<p>看晕了吧？用一张图来表示这些乱七八糟的关系就是：</p>
<p><img src="files/attachments/00143529922671163eebb527bc14547ac11363bf186557d000.png" alt="protos"></p>
<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>
<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>
<p>现在我们就认为<code>xiaoming</code>、<code>xiaohong</code>这些对象“继承”自<code>Student</code>。</p>
<p>不过还有一个小问题，注意观察：</p>
<pre><code>xiaoming.name; // '小明'
xiaohong.name; // '小红'
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
</code></pre>
<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>name</code>不同，这是对的，否则我们无法区分谁是谁了。</p>
<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>
<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。</p>
<p>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：</p>
<p><img src="files/attachments/001435299854512faf32868f60348be878982909b5a5d04000.png" alt="protos2"></p>
<p>修改代码如下：</p>
<pre><code>function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
</code></pre>
<p>用<code>new</code>创建基于原型的JavaScript的对象就是这么简单！</p>
<h4 id="-new-">忘记写new怎么办</h4>
<p>如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写<code>new</code>怎么办？</p>
<p>在strict模式下，<code>this.name = name</code>将报错，因为<code>this</code>绑定为<code>undefined</code>，在非strict模式下，<code>this.name = name</code>不报错，因为<code>this</code>绑定为<code>window</code>，于是无意间创建了全局变量<code>name</code>，并且返回<code>undefined</code>，这个结果更糟糕。</p>
<p>所以，调用构造函数千万不要忘记写<code>new</code>。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如<a href="http://www.jslint.com/">jslint</a>将可以帮你检测到漏写的<code>new</code>。</p>
<p>最后，我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的<code>new</code>操作。一个常用的编程模式像这样：</p>
<pre><code>function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}
</code></pre>
<p>这个<code>createStudent()</code>函数有几个巨大的优点：一是不需要<code>new</code>来调用，二是参数非常灵活，可以不传，也可以这么传：</p>
<pre><code>var xiaoming = createStudent({
    name: '小明'
});

xiaoming.grade; // 1
</code></pre>
<p>如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从<code>JSON</code>拿到了一个对象，就可以直接创建出<code>xiaoming</code>。</p>
<h4 id="-">练习</h4>
<p>请利用构造函数定义<code>Cat</code>，并让所有的Cat对象有一个<code>name</code>属性，并共享一个方法<code>say()</code>，返回字符串<code>'Hello, xxx!'</code>：</p>
<pre class="x-javascript">
'use strict';
----
function Cat(name) {
    //
}
----
// 测试:
var kitty = new Cat('Kitty');
var doraemon = new Cat('哆啦A梦');
if (kitty &amp;&amp; kitty.name === 'Kitty' &amp;&amp; kitty.say &amp;&amp; typeof kitty.say === 'function' &amp;&amp; kitty.say() === 'Hello, Kitty!' &amp;&amp; kitty.say === doraemon.say) {
    alert('测试通过!');
} else {
    alert('测试失败!');
}
</pre>
<h2>原型继承</h2>
<p>在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。</p>
<p>由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。</p>
<p>但是办法还是有的。我们先回顾<code>Student</code>构造函数：</p>
<pre><code>function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
</code></pre>
<p>以及<code>Student</code>的原型链：</p>
<p><img src="files/attachments/001439872136313496e60e07ed143bda40a0200b12d8cc3000.png" alt="js-proto"></p>
<p>现在，我们要基于<code>Student</code>扩展出<code>PrimaryStudent</code>，可以先定义出<code>PrimaryStudent</code>：</p>
<pre><code>function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
</code></pre>
<p>但是，调用了<code>Student</code>构造函数不等于继承了<code>Student</code>，<code>PrimaryStudent</code>创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>这样，原型链对了，继承关系就对了。新的基于<code>PrimaryStudent</code>创建的对象不但能调用<code>PrimaryStudent.prototype</code>定义的方法，也可以调用<code>Student.prototype</code>定义的方法。</p>
<p>如果你想用最简单粗暴的方法这么干：</p>
<pre><code>PrimaryStudent.prototype = Student.prototype;
</code></pre>
<p>是不行的！如果这样的话，<code>PrimaryStudent</code>和<code>Student</code>共享一个原型对象，那还要定义<code>PrimaryStudent</code>干啥？</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向<code>Student.prototype</code>。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数<code>F</code>来实现：</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre>
<p>用一张图来表示新的原型链：</p>
<p><img src="files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000.png" alt="js-proto-extend"></p>
<p>注意，函数<code>F</code>仅用于桥接，我们仅创建了一个<code>new F()</code>实例，而且，没有改变原有的<code>Student</code>定义的原型链。</p>
<p>如果把继承这个动作用一个<code>inherits()</code>函数封装起来，还可以隐藏<code>F</code>的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
</code></pre>
<p>这个<code>inherits()</code>函数可以复用：</p>
<pre><code>function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
</code></pre>
<h4 id="-">小结</h4>
<p>JavaScript的原型继承实现方式就是：</p>
<ol>
<li><p>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</p>
</li>
<li><p>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</p>
</li>
<li><p>继续在新的构造函数的原型上定义新方法。</p>
</li>
</ol>
<h1>浏览器</h1>
<p>由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。</p>
<p>目前主流的浏览器分这么几种：</p>
<ul>
<li><p>IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</p>
</li>
<li><p>Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</p>
</li>
<li><p>Sarafi：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.10 Yosemite自带的Sarafi版本是8.x，早已支持ES6；</p>
</li>
<li><p>Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</p>
</li>
<li><p>移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。</p>
</li>
</ul>
<p>其他浏览器如Opera等由于市场份额太小就被自动忽略了。</p>
<p>另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。</p>
<p>不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。</p>
<p>在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。</p>
<h2>浏览器对象</h2>
<p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<h4 id="window">window</h4>
<p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p><code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p>兼容性：IE&lt;=8不支持。</p>
<pre class="x-javascript">
'use strict';
----
// 可以调整浏览器窗口大小试试:
alert('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
</pre>
<p>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p>
<h4 id="navigator">navigator</h4>
<p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括：</p>
<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li>
</ul>
<pre class="x-javascript">
'use strict';
----
alert('appName = ' + navigator.appName + '\n' +
      'appVersion = ' + navigator.appVersion + '\n' +
      'language = ' + navigator.language + '\n' +
      'platform = ' + navigator.platform + '\n' +
      'userAgent = ' + navigator.userAgent);
</pre>
<p><em>请注意</em>，<code>navigator</code>的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用<code>if</code>判断浏览器版本，例如：</p>
<pre><code>var width;
if (getIEVersion(navigator.userAgent) &lt; 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}
</code></pre>
<p>但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回<code>undefined</code>的特性，直接用短路运算符<code>||</code>计算：</p>
<pre><code>var width = window.innerWidth || document.body.clientWidth;
</code></pre>
<h4 id="screen">screen</h4>
<p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p>
<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
<pre class="x-javascript">
'use strict';
----
alert('Screen size = ' + screen.width + ' x ' + screen.height);
</pre>
<h4 id="location">location</h4>
<p><code>location</code>对象表示当前页面的URL信息。例如，一个完整的URL：</p>
<pre><code>http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP
</code></pre>
<p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p>
<pre><code>location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&amp;b=2'
location.hash; // 'TOP'
</code></pre>
<p>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。</p>
<pre class="x-javascript">
'use strict';
----
if (confirm('重新加载当前页' + location.href + '?')) {
    location.reload();
} else {
    location.assign('/discuss'); // 设置一个新的URL地址
}
</pre>
<h4 id="document">document</h4>
<p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p>
<p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变：</p>
<pre class="x-javascript">
'use strict';
----
document.title = '努力学习JavaScript!';
</pre>
<p>请观察浏览器窗口标题的变化。</p>
<p>要查找DOM树的某个节点，需要从<code>document</code>对象开始查找。最常用的查找是根据ID和Tag Name。</p>
<p>我们先准备HTML数据：</p>
<pre><code>&lt;dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;"&gt;
    &lt;dt&gt;摩卡&lt;/dt&gt;
    &lt;dd&gt;热摩卡咖啡&lt;/dd&gt;
    &lt;dt&gt;酸奶&lt;/dt&gt;
    &lt;dd&gt;北京老酸奶&lt;/dd&gt;
    &lt;dt&gt;果汁&lt;/dt&gt;
    &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p>用<code>document</code>对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：</p>
<pre class="x-javascript">
'use strict';
----
var menu = document.getElementById('drink-menu');
var drinks = document.getElementsByTagName('dt');
var i, s, menu, drinks;

menu = document.getElementById('drink-menu');
menu.tagName; // 'DL'

drinks = document.getElementsByTagName('dt');
s = '提供的饮料有:';
for (i=0; i&lt;drinks.length; i++) {
    s = s + drinks[i].innerHTML + ',';
}
alert(s);
</pre>
<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
    <dt>摩卡</dt>
    <dd>热摩卡咖啡</dd>
    <dt>酸奶</dt>
    <dd>北京老酸奶</dd>
    <dt>果汁</dt>
    <dd>鲜榨苹果汁</dd>
</dl>
<p><code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。</p>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
<pre><code>document.cookie; // 'v=123; remember=true; prefer=zh'
</code></pre>
<p>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
<pre><code>&lt;!-- 当前页面在wwwexample.com --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="http://www.foo.com/jquery.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    ...
&lt;/html&gt;
</code></pre>
<p>如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。</p>
<p>为了解决这个问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，设定了<code>httpOnly</code>的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持<code>httpOnly</code>选项，IE从IE6 SP1开始支持。</p>
<p>为了确保安全，服务器端在设置Cookie时，应该始终坚持使用<code>httpOnly</code>。</p>
<h4 id="history">history</h4>
<p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p>
<p>任何情况，你都不应该使用<code>history</code>这个对象了。</p>
<h2>操作DOM</h2>
<p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li><p>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</p>
</li>
<li><p>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</p>
</li>
<li><p>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</p>
</li>
<li><p>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</p>
</li>
</ul>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code>，以及CSS选择器<code>document.getElementsByClassName()</code>。</p>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<p>例如：</p>
<pre><code>// 返回ID为'test'的节点：
var test = document.getElementById('test');

// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
var trs = document.getElementById('test-table').getElementsByTagName('tr');

// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById('test-div').getElementsByClassName('red');

// 获取节点test下的所有直属子节点:
var cs = test.children;

// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;
</code></pre>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
<pre><code>// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted &gt; p');
</code></pre>
<p>注意：低版本的IE&lt;8不支持<code>querySelector</code>和<code>querySelectorAll</code>。IE8仅有限支持。</p>
<p>严格地讲，我们这里的DOM节点是指<code>Element</code>，但是DOM节点实际上是<code>Node</code>，在HTML中，<code>Node</code>包括<code>Element</code>、<code>Comment</code>、<code>CDATA_SECTION</code>等很多种，以及根节点<code>Document</code>类型，但是，绝大多数时候我们只关心<code>Element</code>，也就是实际控制页面结构的<code>Node</code>，其他类型的<code>Node</code>忽略即可。根节点<code>Document</code>已经自动绑定为全局变量<code>document</code>。</p>
<h4 id="-">练习</h4>
<p>如下的HTML结构：</p>
<div id="test-div">
  <div class="c-red">
    <p id="test-p">JavaScript</p>
    <p>Java</p>
  </div>
  <div class="c-red c-green">
    <p>Python</p>
    <p>Ruby</p>
    <p>Swift</p>
  </div>
  <div class="c-green">
    <p>Scheme</p>
    <p>Haskell</p>
  </div>
</div>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-div"&gt;
&lt;div class="c-red"&gt;
    &lt;p id="test-p"&gt;JavaScript&lt;/p&gt;
    &lt;p&gt;Java&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="c-red c-green"&gt;
    &lt;p&gt;Python&lt;/p&gt;
    &lt;p&gt;Ruby&lt;/p&gt;
    &lt;p&gt;Swift&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="c-green"&gt;
    &lt;p&gt;Scheme&lt;/p&gt;
    &lt;p&gt;Haskell&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>请选择出指定条件的节点：</p>
<pre class="x-javascript">
'use strict';
----
// 选择&lt;p&gt;JavaScript&lt;/p&gt;:
var js = ???;

// 选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:
var arr = ???;

// 选择&lt;p&gt;Haskell&lt;/p&gt;:
var haskell = ???;
----
// 测试:
if (!js || js.innerText !== 'JavaScript') {
    alert('选择JavaScript失败!');
} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') {
    alert('选择Python,Ruby,Swift失败!');
} else if (!haskell || haskell.innerText !== 'Haskell') {
    alert('选择Haskell失败!');
} else {
    alert('测试通过!');
}
</pre>
<h3>更新DOM</h3>
<p>拿到一个DOM节点后，我们可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种：</p>
<p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
<pre><code>// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // &lt;p id="p-id"&gt;ABC&lt;/p&gt;
// 设置HTML:
p.innerHTML = 'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ';
// &lt;p&gt;...&lt;/p&gt;的内部结构已修改
</code></pre>
<p>用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。</p>
<p>第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：</p>
<pre><code>// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '&lt;script&gt;alert("Hi")&lt;/script&gt;';
// HTML被自动编码，无法设置一个&lt;script&gt;节点:
// &lt;p id="p-id"&gt;&amp;lt;script&amp;gt;alert("Hi")&amp;lt;/script&amp;gt;&lt;/p&gt;
</code></pre>
<p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意IE&lt;9不支持<code>textContent</code>。</p>
<p>修改CSS也是经常需要的操作。DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>：</p>
<pre><code>// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';
</code></pre>
<h4 id="-">练习</h4>
<p>有如下的HTML结构：</p>
<div id="test-div">
  <p id="test-js">javascript</p>
  <p>Java</p>
</div>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-div"&gt;
  &lt;p id="test-js"&gt;javascript&lt;/p&gt;
  &lt;p&gt;Java&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>请尝试获取指定节点并修改：</p>
<pre class="x-javascript">
'use strict';
----
// 获取&lt;p&gt;javascript&lt;/p&gt;节点:
var js = ???;

// 修改文本为JavaScript:
// TODO:

// 修改CSS为: color: #ff0000, font-weight: bold
// TODO:
----
// 测试:
if (js &amp;&amp; js.parentNode &amp;&amp; js.parentNode.id === 'test-div' &amp;&amp; js.id === 'test-js') {
    if (js.innerText === 'JavaScript') {
        if (js.style &amp;&amp; js.style.fontWeight === 'bold' &amp;&amp; (js.style.color === 'red' || js.style.color === '#ff0000' || js.style.color === '#f00' || js.style.color === 'rgb(255, 0, 0)')) {
            alert('测试通过!');
        } else {
            alert('CSS样式测试失败!');
        }
    } else {
        alert('文本测试失败!');
    }
} else {
    alert('节点测试失败!');
}
</pre>
<h3>插入DOM</h3>
<p>当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？</p>
<p>如果这个DOM节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = '&lt;span&gt;child&lt;/span&gt;'</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p>
<p>如果这个DOM节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用<code>appendChild</code>，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;p id="js"&gt;JavaScript&lt;/p&gt;
&lt;div id="list"&gt;
    &lt;p id="java"&gt;Java&lt;/p&gt;
    &lt;p id="python"&gt;Python&lt;/p&gt;
    &lt;p id="scheme"&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>把<code>&lt;p id="js"&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id="list"&gt;</code>的最后一项：</p>
<pre><code>var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
</code></pre>
<p>现在，HTML结构变成了这样：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="list"&gt;
    &lt;p id="java"&gt;Java&lt;/p&gt;
    &lt;p id="python"&gt;Python&lt;/p&gt;
    &lt;p id="scheme"&gt;Scheme&lt;/p&gt;
    &lt;p id="js"&gt;JavaScript&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>因为我们插入的<code>js</code>节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候我们会从零创建一个新的节点，然后插入到指定位置：</p>
<pre><code>var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
</code></pre>
<p>这样我们就动态添加了一个新的节点：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="list"&gt;
    &lt;p id="java"&gt;Java&lt;/p&gt;
    &lt;p id="python"&gt;Python&lt;/p&gt;
    &lt;p id="scheme"&gt;Scheme&lt;/p&gt;
    &lt;p id="haskell"&gt;Haskell&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<code>&lt;style&gt;</code>节点，然后把它添加到<code>&lt;head&gt;</code>节点的末尾，这样就动态地给文档添加了新的CSS定义：</p>
<pre><code>var d = document.createElement('style');
d.setAttribute('type', 'text/css');
d.innerHTML = 'p { color: red }';
document.getElementsByTagName('head')[0].appendChild(d);
</code></pre>
<p>可以在Chrome的控制台执行上述代码，观察页面样式的变化。</p>
<h4 id="insertbefore">insertBefore</h4>
<p>如果我们要把子节点插入到指定的位置怎么办？可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到<code>referenceElement</code>之前。</p>
<p>还是以上面的HTML为例，假定我们要把<code>Haskell</code>插入到<code>Python</code>之前：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="list"&gt;
    &lt;p id="java"&gt;Java&lt;/p&gt;
    &lt;p id="python"&gt;Python&lt;/p&gt;
    &lt;p id="scheme"&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>可以这么写：</p>
<pre><code>var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
</code></pre>
<p>新的HTML结构如下：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="list"&gt;
    &lt;p id="java"&gt;Java&lt;/p&gt;
    &lt;p id="haskell"&gt;Haskell&lt;/p&gt;
    &lt;p id="python"&gt;Python&lt;/p&gt;
    &lt;p id="scheme"&gt;Scheme&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>可见，使用<code>insertBefore</code>重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代<code>children</code>属性实现：</p>
<pre><code>var
    i, c,
    list = document.getElementById('list');
for (i = 0; i &lt; list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}
</code></pre>
<h4 id="-">练习</h4>
<p>对于一个已有的HTML结构：</p>
<ol id="test-list">
    <li class="lang">Scheme</li>
    <li class="lang">JavaScript</li>
    <li class="lang">Python</li>
    <li class="lang">Ruby</li>
    <li class="lang">Haskell</li>
</ol>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ol id="test-list"&gt;
    &lt;li class="lang"&gt;Scheme&lt;/li&gt;
    &lt;li class="lang"&gt;JavaScript&lt;/li&gt;
    &lt;li class="lang"&gt;Python&lt;/li&gt;
    &lt;li class="lang"&gt;Ruby&lt;/li&gt;
    &lt;li class="lang"&gt;Haskell&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>按字符串顺序重新排序DOM节点：</p>
<pre class="x-javascript">
'use strict';
----
// sort list:
----
// 测试:
;(function () {
    var
        arr, i,
        t = document.getElementById('test-list');
    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 5) {
        arr = [];
        for (i=0; i&lt;t.children.length; i++) {
            arr.push(t.children[i].innerText);
        }
        if (arr.toString() === ['Haskell', 'JavaScript', 'Python', 'Ruby', 'Scheme'].toString()) {
            alert('测试通过!');
        }
        else {
            alert('测试失败: ' + arr.toString());
        }
    }
    else {
        alert('测试失败!');
    }
})();
</pre>
<h3>删除DOM</h3>
<p>删除一个DOM节点就比插入要容易得多。</p>
<p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉：</p>
<pre><code>// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
</code></pre>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。</p>
<p>例如，对于如下HTML结构：</p>
<pre><code>&lt;div id="parent"&gt;
    &lt;p&gt;First&lt;/p&gt;
    &lt;p&gt;Second&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>当我们用如下代码删除子节点时：</p>
<pre><code>var parent = document.getElementById('parent');
parent.removeChild(parent.children[0]);
parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错
</code></pre>
<p>浏览器报错：<code>parent.children[1]</code>不是一个有效的节点。原因就在于，当<code>&lt;p&gt;First&lt;/p&gt;</code>节点被删除后，<code>parent.children</code>的节点数量已经从2变为了1，索引<code>[1]</code>已经不存在了。</p>
<p>因此，删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p>
<h4 id="-">练习</h4>
<ul id="test-list">
    <li>JavaScript</li>
    <li>Swift</li>
    <li>HTML</li>
    <li>ANSI C</li>
    <li>CSS</li>
    <li>DirectX</li>
</ul>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul id="test-list"&gt;
    &lt;li&gt;JavaScript&lt;/li&gt;
    &lt;li&gt;Swift&lt;/li&gt;
    &lt;li&gt;HTML&lt;/li&gt;
    &lt;li&gt;ANSI C&lt;/li&gt;
    &lt;li&gt;CSS&lt;/li&gt;
    &lt;li&gt;DirectX&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>把与Web开发技术不相关的节点删掉：</p>
<pre class="x-javascript">
'use strict';
----
// TODO
----
// 测试:
;(function () {
    var
        arr, i,
        t = document.getElementById('test-list');
    if (t &amp;&amp; t.children &amp;&amp; t.children.length === 3) {
        arr = [];
        for (i = 0; i &lt; t.children.length; i ++) {
            arr.push(t.children[i].innerText);
        }
        if (arr.toString() === ['JavaScript', 'HTML', 'CSS'].toString()) {
            alert('测试通过!');
        }
        else {
            alert('测试失败: ' + arr.toString());
        }
    }
    else {
        alert('测试失败!');
    }
})();
</pre>
<h2>操作表单</h2>
<p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ul>
<li><p>文本框，对应的<code>&lt;input type="text"&gt;</code>，用于输入文本；</p>
</li>
<li><p>口令框，对应的<code>&lt;input type="password"&gt;</code>，用于输入口令；</p>
</li>
<li><p>单选框，对应的<code>&lt;input type="radio"&gt;</code>，用于选择一项；</p>
</li>
<li><p>复选框，对应的<code>&lt;input type="checkbox"&gt;</code>，用于选择多项；</p>
</li>
<li><p>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</p>
</li>
<li><p>隐藏文本，对应的<code>&lt;input type="hidden"&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</p>
</li>
</ul>
<h4 id="-">获取值</h4>
<p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用<code>value</code>获得对应的用户输入值：</p>
<pre><code>// &lt;input type="text" id="email"&gt;
var input = document.getElementById('email');
input.value; // '用户输入的值'
</code></pre>
<p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断：</p>
<pre><code>// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;
var mon = document.getElementById('monday');
var tue = document.getElementById('tuesday');
mon.value; // '1'
tue.value; // '2'
mon.checked; // true或者false
tue.checked; // true或者false
</code></pre>
<h4 id="-">设置值</h4>
<p>设置值和获取值类似，对于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以：</p>
<pre><code>// &lt;input type="text" id="email"&gt;
var input = document.getElementById('email');
input.value = 'test@example.com'; // 文本框的内容已更新
</code></pre>
<p>对于单选框和复选框，设置<code>checked</code>为<code>true</code>或<code>false</code>即可。</p>
<h4 id="html5-">HTML5控件</h4>
<p>HTML5新增了大量标准控件，常用的包括<code>date</code>、<code>datetime</code>、<code>datetime-local</code>、<code>color</code>等，它们都使用<code>&lt;input&gt;</code>标签：</p>
<pre><code>&lt;input type="date" value="2015-07-01"&gt;
</code></pre>
<input type="date" value="2015-07-01">
<pre><code>&lt;input type="datetime-local" value="2015-07-01T02:03:04"&gt;
</code></pre>
<input type="datetime-local" value="2015-07-01T02:03:04">
<pre><code>&lt;input type="color" value="#ff0000"&gt;
</code></pre>
<input type="color" value="#ff0000">
<p>不支持HTML5的浏览器无法识别新的控件，会把它们当做<code>type="text"</code>来显示。支持HTML5的浏览器将获得格式化的字符串。例如，<code>type="date"</code>类型的<code>input</code>的<code>value</code>将保证是一个有效的<code>YYYY-MM-DD</code>格式的日期，或者空字符串。</p>
<h4 id="-">提交表单</h4>
<p>最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。</p>
<p>方式一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的<code>click</code>事件，在JavaScript代码中提交表单：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id="test-form1"&gt;
    &lt;input type="text" name="test"&gt;
    &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function doSubmitForm() {
    var form = document.getElementById('test-form1');
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
&lt;/script&gt;
</code></pre>
<p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type="submit"&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id="test-form2" onsubmit="return checkForm()"&gt;
    &lt;input type="text" name="test"&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var form = document.getElementById('test-form2');
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
&lt;/script&gt;
</code></pre>
<p>注意要<code>return true</code>来告诉浏览器继续提交，如果<code>return false</code>，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type="hidden"&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<code>&lt;input&gt;</code>：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt;
    &lt;input type="text" id="username" name="username"&gt;
    &lt;input type="password" id="password" name="password"&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var pwd = document.getElementById('password');
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;
</code></pre>
<p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<code>&lt;input type="hidden"&gt;</code>实现：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt;
    &lt;input type="text" id="username" name="username"&gt;
    &lt;input type="password" id="input-password"&gt;
    &lt;input type="hidden" id="md5-password" name="password"&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
function checkForm() {
    var input_pwd = document.getElementById('input-password');
    var md5_pwd = document.getElementById('md5-password');
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
&lt;/script&gt;
</code></pre>
<p>注意到<code>id</code>为<code>md5-password</code>的<code>&lt;input&gt;</code>标记了<code>name="password"</code>，而用户输入的<code>id</code>为<code>input-password</code>的<code>&lt;input&gt;</code>没有<code>name</code>属性。没有<code>name</code>属性的<code>&lt;input&gt;</code>的数据不会被提交。</p>
<h4 id="-">练习</h4>
<p>利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单：</p>
<ul>
<li><p>用户名必须是3-10位英文字母或数字；</p>
</li>
<li><p>口令必须是6-20位；</p>
</li>
<li><p>两次输入口令必须一致。</p>
</li>
</ul>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;form id="test-register" action="#" target="_blank" onsubmit="return checkRegisterForm()"&gt;
    &lt;p id="test-error" style="color:red"&gt;&lt;/p&gt;
    &lt;p&gt;
        用户名: &lt;input type="text" id="username" name="username"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        口令: &lt;input type="password" id="password" name="password"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        重复口令: &lt;input type="password" id="password-2"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;button type="reset"&gt;重置&lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;
</code></pre>
<form id="test-register" action="#test-submit" target="_blank" onsubmit="return checkForm()">
    <p id="test-error" style="color:red"></p>
    <p>
        用户名: <input type="text" id="username" name="username">
    </p>
    <p>
        口令: <input type="password" id="password" name="password">
    </p>
    <p>
        重复口令: <input type="password" id="password-2">
    </p>
    <p>
        <button type="submit">提交</button> <button type="reset">重置</button>
    </p>
</form>
<script>
window.testFormHandler = function () {
    return false;
}

function checkForm() {
    var r = window.testFormHandler();
    if (r === false) {
        console.log('checkRegisterForm() return false!');
    } else {
        alert('Form可以正常提交！');
    }
    return r;
}
</script>
<pre class="x-javascript">
'use strict';
var checkRegisterForm = function () {
----
    // TODO:
    return false;
}
----
// 测试:
;(function () {
    window.testFormHandler = checkRegisterForm;
    var form = document.getElementById('test-register');
    if (form.dispatchEvent) {
        var event = new Event('submit', {
            bubbles: true,
            cancelable: true
          });
        form.dispatchEvent(event);
    } else {
        form.fireEvent('onsubmit');
    }
})();
</pre>
<h2>操作文件</h2>
<p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type="file"&gt;</code>。</p>
<p><em>注意</em>：当一个表单包含<code>&lt;input type="file"&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。</p>
<p>出于安全考虑，浏览器只允许用户点击<code>&lt;input type="file"&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type="file"&gt;</code>的<code>value</code>赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：</p>
<script>
$(function () {
    var
        fileInput = document.getElementById('test-file-upload'),
        filePath = document.getElementById('test-get-filename');
    fileInput.addEventListener('change', function () {
        filePath.innerText = fileInput.value;
    });
});
</script>
<form method="post" action="http://localhost/test" enctype="multipart/form-data">
    <p>
        <input type="file" id="test-file-upload" name="test">
    </p>
    <p>待上传文件: <span id="test-get-filename" style="color:red"></span></p>
</form>
<p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：</p>
<pre><code>var f = document.getElementById('test-file-upload');
var filename = f.value; // 'C:\fakepath\test.png'
if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
    alert('Can only upload image file.');
    return false;
}
</code></pre>
<h4 id="file-api">File API</h4>
<p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。</p>
<p>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p>
<p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
<script>
$(function() {
    var fileInput = document.getElementById('test-image-file');
    var info = document.getElementById('test-file-info');
    var preview = document.getElementById('test-image-preview');
    fileInput.addEventListener('change', function () {
        preview.style.backgroundImage = '';
        if (!fileInput.value) {
            info.innerHTML = '没有选择文件';
            return;
        }
        var file = fileInput.files[0];
        info.innerHTML = '文件: ' + file.name + '<br>' +
                         '大小: ' + file.size + '<br>' +
                         '修改: ' + file.lastModifiedDate;
        if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
            alert('不是有效的图片文件!');
            return;
        }
        var reader = new FileReader();
        reader.onload = function(e) {
            var
                data = e.target.result;
                index = data.indexOf(';base64,');
            preview.style.backgroundImage = 'url(' + data + ')';
        };
        reader.readAsDataURL(file);
    });
});
</script>
<form method="post" action="http://localhost/test" enctype="multipart/form-data">
    <p>图片预览：</p>
    <p></p><div id="test-image-preview" style="border: 1px solid #ccc; width: 100%; height: 200px; background-size: contain; background-repeat: no-repeat; background-position: center center;"></div>
    <p>
        <input type="file" id="test-image-file" name="test">
    </p>
    <p id="test-file-info"></p>
</form>
<pre><code>var
    fileInput = document.getElementById('test-image-file'),
    info = document.getElementById('test-file-info'),
    preview = document.getElementById('test-image-preview');
// 监听change事件:
fileInput.addEventListener('change', function () {
    // 清除背景图片:
    preview.style.backgroundImage = '';
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = '没有选择文件';
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' +
                     '大小: ' + file.size + '&lt;br&gt;' +
                     '修改: ' + file.lastModifiedDate;
    if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') {
        alert('不是有效的图片文件!');
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(e) {
        var
            data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'
        preview.style.backgroundImage = 'url(' + data + ')';
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
});
</code></pre>
<p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串<code>base64,</code>后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
<h4 id="-">回调</h4>
<p>上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>你可能会问，单线程模式执行的JavaScript，如何处理多任务？</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<pre><code>reader.readAsDataURL(file);
</code></pre>
<p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<pre><code>reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
</code></pre>
<p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<h2>AJAX</h2>
<p>AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p>
<p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象：</p>
<pre class="x-javascript">
'use strict';
----
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
</pre>
<textarea id="test-response-text" rows="5" style="width: 90%; margin: 15px 0; resize: none;">
响应结果：
</textarea>
<p>对于低版本的IE，需要换一个<code>ActiveXObject</code>对象：</p>
<pre class="x-javascript">
'use strict';
----
function success(text) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
</pre>
<textarea id="test-ie-response-text" rows="5" style="width: 90%; margin: 15px 0; resize: none;">
IE响应结果：
</textarea>
<p>如果你想把标准写法和IE写法混在一起，可以这么写：</p>
<pre><code>var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject('Microsoft.XMLHTTP');
}
</code></pre>
<p>通过检测<code>window</code>对象是否有<code>XMLHttpRequest</code>属性来确定浏览器是否支持标准的<code>XMLHttpRequest</code>。注意，<em>不要</em>根据浏览器的<code>navigator.userAgent</code>来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。</p>
<p>当创建了<code>XMLHttpRequest</code>对象后，要先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成，如果已完成，再根据<code>status === 200</code>判断是否是一个成功的响应。</p>
<p><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，第一个参数指定是<code>GET</code>还是<code>POST</code>，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写。</p>
<p><em>注意</em>，千万不要把第三个参数指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</p>
<p>最后调用<code>send()</code>方法才真正发送请求。<code>GET</code>请求不需要参数，<code>POST</code>请求需要把body部分以字符串或者<code>FormData</code>对象传进去。</p>
<h4 id="-">安全限制</h4>
<p>上面代码的URL使用的是相对路径。如果你把它改为<code>'http://www.sina.com.cn/'</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同（<code>www.example.com</code>和<code>example.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口号要相同（默认是<code>:80</code>端口，它和<code>:8080</code>就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</p>
<p>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：</p>
<p>一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<p>二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<pre><code>'/proxy?url=http://www.sina.com.cn'
</code></pre>
<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<p>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script src="http://example.com/abc.js"&gt;&lt;/script&gt;
    ...
&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：</p>
<pre><code>foo('data');
</code></pre>
<p>这样一来，我们如果在页面中先准备好<code>foo()</code>函数，然后给页面动态加一个<code>&lt;script&gt;</code>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</p>
<p>以163的股票查询URL为例，对于URL：<a href="http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice">http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice</a>，你将得到如下返回：</p>
<pre><code>refreshPrice({"0000001":{"code": "0000001", ... });
</code></pre>
<p>因此我们需要首先在页面中准备好回调函数：</p>
<script>
function refreshPrice(data) {
    var p = document.getElementById('test-jsonp');
    p.innerHTML = '当前价格：' +
        data['0000001'].name +': ' +
        data['0000001'].price + '；' +
        data['1399001'].name + ': ' +
        data['1399001'].price;
}
function getPrice() {
    var
        js = document.createElement('script'),
        head = document.getElementsByTagName('head')[0];
    js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice';
    head.appendChild(js);
}
</script>
<pre><code>function refreshPrice(data) {
    var p = document.getElementById('test-jsonp');
    p.innerHTML = '当前价格：' +
        data['0000001'].name +': ' +
        data['0000001'].price + '；' +
        data['1399001'].name + ': ' +
        data['1399001'].price;
}
</code></pre>
<div>
    <p id="test-jsonp">当前价格：</p>
    <p><button type="button" onclick="getPrice()">刷新</button></p>
</div>
<p>最后用<code>getPrice()</code>函数触发：</p>
<pre><code>function getPrice() {
    var
        js = document.createElement('script'),
        head = document.getElementsByTagName('head')[0];
    js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice';
    head.appendChild(js);
}
</code></pre>
<p>就完成了跨域加载数据。</p>
<h4 id="cors">CORS</h4>
<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>了解CORS前，我们先搞明白概念：</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>用一个图来表示就是：</p>
<p><img src="files/attachments/00143640805071744d58164a40e42ef92b9973824451595000.png" alt="js-cors"></p>
<p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型
仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，<code>X-Custom: 12345</code>），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>
<pre><code>/* CSS */
@font-face {
  font-family: 'FontAwesome';
  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');
}
</code></pre>
<p>如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个<code>OPTIONS</code>请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<pre><code>OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
</code></pre>
<p>服务器必须响应并明确指出允许的Method：</p>
<pre><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
</code></pre>
<p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p>
<p>需要深入了解CORS的童鞋请移步<a href="http://www.w3.org/TR/cors/">W3C文档</a>。</p>
<h2>Promise</h2>
<p>在JavaScript的世界中，所有代码都是单线程执行的。</p>
<p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p>
<pre><code>function callback() {
    console.log('Done');
}
console.log('before setTimeout()');
setTimeout(callback, 1000); // 1秒钟后调用callback函数
console.log('after setTimeout()');
</code></pre>
<p>观察上述代码执行，在Chrome的控制台输出可以看到：</p>
<pre><code>before setTimeout()
after setTimeout()
(等待1秒后)
Done
</code></pre>
<p>可见，异步操作会在将来的某个时间点触发一个函数调用。</p>
<p>AJAX就是典型的异步操作。以上一节的代码为例：</p>
<pre><code>request.onreadystatechange = function () {
    if (request.readyState === 4) {
        if (request.status === 200) {
            return success(request.responseText);
        } else {
            return fail(request.status);
        }
    }
}
</code></pre>
<p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p>
<p>有没有更好的写法？比如写成这样：</p>
<pre><code>var ajax = ajaxGet('http://...');
ajax.ifSuccess(success)
    .ifFail(fail);
</code></pre>
<p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数或<code>fail</code>函数。</p>
<p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。</p>
<p>Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：</p>
<pre class="x-javascript">
'use strict';

new Promise(function () {});
----
// 直接运行测试:
alert('支持Promise!');
</pre>
<p>我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：</p>
<pre><code>function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut &lt; 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}
</code></pre>
<p>这个<code>test()</code>函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用<code>resolve('200 OK')</code>，如果执行失败，我们将调用<code>reject('timeout in ' + timeOut + ' seconds.')</code>。可以看出，<code>test()</code>函数只关心自身的逻辑，并不关心具体的<code>resolve</code>和<code>reject</code>将如何处理结果。</p>
<p>有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：</p>
<pre><code>var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log('成功：' + result);
});
var p3 = p2.catch(function (reason) {
    console.log('失败：' + reason);
});
</code></pre>
<p>变量<code>p1</code>是一个Promise对象，它负责执行<code>test</code>函数。由于<code>test</code>函数在内部是异步执行的，当<code>test</code>函数执行成功时，我们告诉Promise对象：</p>
<pre><code>// 如果成功，执行这个函数：
p1.then(function (result) {
    console.log('成功：' + result);
});
</code></pre>
<p>当<code>test</code>函数执行失败时，我们告诉Promise对象：</p>
<pre><code>p2.catch(function (reason) {
    console.log('失败：' + reason);
});
</code></pre>
<p>Promise对象可以串联起来，所以上述代码可以简化为：</p>
<pre><code>new Promise(test).then(function (result) {
    console.log('成功：' + result);
}).catch(function (reason) {
    console.log('失败：' + reason);
});
</code></pre>
<p>实际测试一下，看看Promise是如何异步执行的：</p>
<pre class="x-javascript">
'use strict';

// 清除log:
var logging = document.getElementById('test-promise-log');
while (logging.children.length &gt; 1) {
    logging.removeChild(logging.children[logging.children.length - 1]);
}

// 输出log到页面:
function log(s) {
    var p = document.createElement('p');
    p.innerHTML = s;
    logging.appendChild(p);
}

----
new Promise(function (resolve, reject) {
    log('start new Promise...');
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut &lt; 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}).then(function (r) {
    log('Done: ' + r);
}).catch(function (reason) {
    log('Failed: ' + reason);
});
</pre>
<div id="test-promise-log" style="border: solid 1px #ccc; padding: 1em; margin: 15px 0;">
    <p>Log:</p>
</div>
<p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：</p>
<p><img src="files/attachments/001436512391628944d5da9a5654a35b0ace38246f30b9c000.png" alt="promise"></p>
<p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p>
<p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p>
<pre><code>job1.then(job2).then(job3).catch(handleError);
</code></pre>
<p>其中，<code>job1</code>、<code>job2</code>和<code>job3</code>都是Promise对象。</p>
<p>下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：</p>
<pre class="x-javascript">
'use strict';

var logging = document.getElementById('test-promise2-log');
while (logging.children.length &gt; 1) {
    logging.removeChild(logging.children[logging.children.length - 1]);
}

function log(s) {
    var p = document.createElement('p');
    p.innerHTML = s;
    logging.appendChild(p);
}

----
// 0.5秒后返回input*input的计算结果:
function multiply(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' x ' + input + '...');
        setTimeout(resolve, 500, input * input);
    });
}

// 0.5秒后返回input+input的计算结果:
function add(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' + ' + input + '...');
        setTimeout(resolve, 500, input + input);
    });
}

var p = new Promise(function (resolve, reject) {
    log('start new Promise...');
    resolve(123);
});

p.then(multiply)
 .then(add)
 .then(multiply)
 .then(add)
 .then(function (result) {
    log('Got value: ' + result);
});
</pre>
<div id="test-promise2-log" style="border: solid 1px #ccc; padding: 1em; margin: 15px 0;">
    <p>Log:</p>
</div>
<p><code>setTimeout</code>可以看成一个模拟网络等异步执行的函数。现在，我们把上一节的AJAX异步执行函数转换为Promise对象，看看用Promise如何简化异步处理：</p>
<pre class="x-javascript">
'use strict';

// ajax函数将返回Promise对象:
function ajax(method, url, data) {
    var request = new XMLHttpRequest();
    return new Promise(function (resolve, reject) {
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    resolve(request.responseText);
                } else {
                    reject(request.status);
                }
            }
        };
        request.open(method, url);
        request.send(data);
    });
}
----
var log = document.getElementById('test-promise-ajax-result');
var p = ajax('GET', '/api/categories');
p.then(function (text) { // 如果AJAX成功，获得响应内容
    log.innerText = text;
}).catch(function (status) { // 如果AJAX失败，获得响应代码
    log.innerText = 'ERROR: ' + status;
});
</pre>
<div id="test-promise-ajax-result" style="border: solid 1px #ccc; padding: 1em; margin: 15px 0;">
    Result:
</div>
<p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用<code>Promise.all()</code>实现如下：</p>
<pre><code>var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});
</code></pre>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p>
<pre><code>var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // 'P1'
});
</code></pre>
<p>由于<code>p1</code>执行较快，Promise的<code>then()</code>将获得结果<code>'P1'</code>。<code>p2</code>仍在继续执行，但执行结果将被丢弃。</p>
<p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p>
<h2>Canvas</h2>
<p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p>
<p>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>
<p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p>
<pre><code>&lt;canvas id="test-canvas" width="300" height="200"&gt;&lt;/canvas&gt;
</code></pre>
<p>由于浏览器对HTML5标准支持不一致，所以，通常在<code>&lt;canvas&gt;</code>内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略<code>&lt;canvas&gt;</code>内部的HTML，如果浏览器不支持Canvas，它将显示<code>&lt;canvas&gt;</code>内部的HTML：</p>
<pre><code>&lt;canvas id="test-stock" width="300" height="200"&gt;
    &lt;p&gt;Current Price: 25.51&lt;/p&gt;
&lt;/canvas&gt;
</code></pre>
<p>在使用Canvas前，用<code>canvas.getContext</code>来测试浏览器是否支持Canvas：</p>
<pre><code>&lt;!-- HTML代码 --&gt;
&lt;canvas id="test-canvas" width="200" heigth="100"&gt;
    &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;
&lt;/canvas&gt;
</code></pre>
<canvas id="test-canvas" width="200" heigth="100" style="border: 1px solid #ccc;">
    <p>你的浏览器不支持Canvas</p>
</canvas>
<pre class="x-javascript">
'use strict';
----
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    alert('你的浏览器支持Canvas!');
} else {
    alert('你的浏览器不支持Canvas!');
}
</pre>
<p><code>getContext('2d')</code>方法让我们拿到一个<code>CanvasRenderingContext2D</code>对象，所有的绘图操作都需要通过这个对象完成。</p>
<pre><code>var ctx = canvas.getContext('2d');
</code></pre>
<p>如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：</p>
<pre><code>gl = canvas.getContext("webgl");
</code></pre>
<p>本节我们只专注于绘制2D图形。</p>
<h4 id="-">绘制形状</h4>
<p>我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：</p>
<p><img src="files/attachments/001436926614788af8f274570d54736bddbbf7b2b03a9eb000.png" alt="canvas-xy"></p>
<p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来绘制图形：</p>
<pre class="x-javascript">
'use strict';

var
    canvas = document.getElementById('test-shape-canvas'),
    ctx = canvas.getContext('2d');
----
ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);
</pre>
<canvas id="test-shape-canvas" width="200" height="200" style="border: 1px solid #ccc; margin-top: 15px;">
</canvas>
<h4 id="-">绘制文本</h4>
<p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<pre class="x-javascript">
'use strict';

var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');
----
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);
</pre>
<canvas id="test-text-canvas" width="300" height="100" style="border: 1px solid #ccc; margin-top: 15px;">
</canvas>
<p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p>
<ul>
<li><p>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</p>
</li>
<li><p>尽量使用整数坐标而不是浮点数；</p>
</li>
<li><p>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</p>
</li>
<li><p>背景图片如果不变可以直接用<code>&lt;img&gt;</code>标签并放到最底层。</p>
</li>
</ul>
<h4 id="-">练习</h4>
<p>请根据从163获取的JSON数据绘制最近30个交易日的K线图，数据已处理为包含一组对象的数组：</p>
<script>
function downloadStockImage() {
    var
        canvas = document.getElementById('stock-canvas'),
        data = canvas.toDataURL();
    window.open(data.replace('image/png', 'image/octet-stream'));
}
</script>
<pre id="pre-demo-code" style="display: none">
window.drawStock = function (data) {
    var
        canvas = document.getElementById('stock-canvas'),
        MAX_X = canvas.width,
        MAX_Y = canvas.height,
        ctx = canvas.getContext('2d');

    var low = data.reduce(function (prev, x) {
        return x.low &lt; prev.low ? x : prev;
    });
    var high = data.reduce(function (prev, x) {
        return x.high &gt; prev.high ? x : prev;
    });

    var chg = high.high - low.low;

    // index range:
    var lowest = Math.floor(low.low - chg * 0.1);
    var highest = Math.floor(high.high + chg * 0.1 + 1);

    var calcY = function (idx) {
        return MAX_Y * (highest - idx) / (highest - lowest);
    };

    var drawAtX = function (x, k) {
        var
            tmp,
            y1 = calcY(k.open),
            y2 = calcY(k.close);
        if (y1 &gt; y2) {
            tmp = y1;
            y1 = y2;
            y2 = tmp;
        }
        ctx.fillStyle = (k.open &gt; k.close) ? '#00ff00' : '#ff0000';
        ctx.fillRect(x, calcY(k.high), 1, calcY(k.low) - calcY(k.high));
        ctx.fillRect(x-2, y1, 5, y2 - y1);
    };

    ctx.clearRect(0, 0, MAX_X, MAX_Y);

    ctx.font = '12px serif';
    ctx.textAlign = 'right';
    ctx.fillStyle = '#000000';
    ctx.fillText(String(Math.floor(high.high)), 40, 15);
    ctx.fillText(String(Math.floor(low.low)), 40, MAX_Y - 20);

    var i, x;
    for (i=0; i&lt;data.length; i++) {
        x = i * 8 + 50;
        drawAtX(x, data[i]);
    }
};
</pre>
<pre class="x-javascript">
'use strict';

window.loadStockData = function (r) {
    var
        NUMS = 30,
        data = r.data;
    if (data.length &gt; NUMS) {
        data = data.slice(data.length - NUMS);
    }
    data = data.map(function (x) {
        return {
            date: x[0],
            open: x[1],
            close: x[2],
            high: x[3],
            low: x[4],
            vol: x[5],
            change: x[6]
        };
    });
    window.drawStock(data);
}

window.drawStock = function (data) {
----
    var
        canvas = document.getElementById('stock-canvas'),
        width = canvas.width,
        height = canvas.height,
        ctx = canvas.getContext('2d');
    console.log(JSON.stringify(data[0])); // {"date":"20150602","open":4844.7,"close":4910.53,"high":4911.57,"low":4797.55,"vol":62374809900,"change":1.69}
    ctx.clearRect(0, 0, width, height);
    ctx.fillText('Test Canvas', 10, 10);
----
};

// 加载最近30个交易日的K线图数据:
var js = document.createElement('script');
js.src = 'http://img1.money.126.net/data/hs/kline/day/history/2015/0000001.json?callback=loadStockData&amp;t=' + Date.now();
document.getElementsByTagName('head')[0].appendChild(js);
</pre>
<canvas id="stock-canvas" width="300" height="200" style="border: 1px solid #ccc; margin-top: 15px;"></canvas>
<p><a id="download-stock" href="#0" onclick="downloadStockImage()">下载为图片</a></p>
<h1>jQuery</h1>
<p>你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。</p>
<p>江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。</p>
<p>jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：</p>
<ul>
<li><p>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</p>
</li>
<li><p>简洁的操作DOM的方法：写<code>$('#test')</code>肯定比<code>document.getElementById('test')</code>来得简洁；</p>
</li>
<li><p>轻松实现动画、修改CSS等各种操作。</p>
</li>
</ul>
<p>jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</p>
<h4 id="jquery-">jQuery版本</h4>
<p>目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。</p>
<p>从<a href="http://jquery.com/download/">jQuery官网</a>可以下载最新版本。jQuery只是一个<code>jquery-xxx.js</code>文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。</p>
<h4 id="-jquery">使用jQuery</h4>
<p>使用jQuery只需要在页面的<code>&lt;head&gt;</code>引入jQuery文件即可：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script src="//code.jquery.com/jquery-1.11.3.min.js"&gt;&lt;/script&gt;
    ...
&lt;/head&gt;
&lt;body&gt;
    ...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>好消息是，当你在学习这个教程时，由于网站本身已经引用了jQuery，所以你可以直接使用：</p>
<pre class="x-javascript">
'use strict';
----
alert('jQuery版本：' + $.fn.jquery);
</pre>
<h4 id="-">$符号</h4>
<p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中，而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名：</p>
<pre><code>window.jQuery; // jQuery(selector, context)
window.$; // jQuery(selector, context)
$ === jQuery; // true
typeof($); // 'function'
</code></pre>
<p><code>$</code>本质上就是一个函数，但是函数也是对象，于是<code>$</code>除了可以直接调用外，也可以有很多其他属性。</p>
<p><em>注意</em>，你看到的<code>$</code>函数名可能不是<code>jQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码<code>$</code>函数可能变成<code>a(b, c)</code>。</p>
<p>绝大多数时候，我们都直接用<code>$</code>（因为写起来更简单嘛）。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们就只能让<code>jQuery</code>把<code>$</code>变量交出来，然后就只能使用<code>jQuery</code>这个变量：</p>
<pre><code>$; // jQuery(selector, context)
jQuery.noConflict();
$; // undefined
jQuery; // jQuery(selector, context)
</code></pre>
<p>这种黑魔法的原理是jQuery在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用<code>jQuery.noConflict()</code>时会把原来保存的变量还原。</p>
<h2>选择器</h2>
<p>选择器是jQuery的核心。一个选择器写出来类似<code>$('#dom-id')</code>。</p>
<p>为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码：</p>
<pre><code>// 按ID查找：
var a = document.getElementById('dom-id');

// 按tag查找：
var divs = document.getElementsByTagNames('div');

// 查找&lt;p class="red"&gt;：
var ps = document.getElementsByTagNames('p');
// 过滤出class="red":
// TODO:

// 查找&lt;table class="green"&gt;里面的所有&lt;tr&gt;：
var table = ...
for (var i=0; i&lt;table.children; i++) {
    // TODO: 过滤出&lt;tr&gt;
}
</code></pre>
<p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找<code>&lt;table class="green"&gt;</code>里面的所有<code>&lt;tr&gt;</code>，一层循环实际上是错的，因为<code>&lt;table&gt;</code>的标准写法是：</p>
<pre><code>&lt;table&gt;
    &lt;tbody&gt;
        &lt;tr&gt;...&lt;/tr&gt;
        &lt;tr&gt;...&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>很多时候，需要递归查找所有子节点。</p>
<p>jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。</p>
<h4 id="-id-">按ID查找</h4>
<p>如果某个DOM节点有<code>id</code>属性，利用jQuery查找如下：</p>
<pre><code>// 查找&lt;div id="abc"&gt;:
var div = $('#abc');
</code></pre>
<p><em>注意</em>，<code>#abc</code>以<code>#</code>开头。返回的对象是jQuery对象。</p>
<p>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
<p>以上面的查找为例，如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>存在，返回的jQuery对象如下：</p>
<pre><code>[&lt;div id="abc"&gt;...&lt;/div&gt;]
</code></pre>
<p>如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>不存在，返回的jQuery对象如下：</p>
<pre><code>[]
</code></pre>
<p>总之jQuery的选择器不会返回<code>undefined</code>或者<code>null</code>，这样的好处是你不必在下一行判断<code>if (div === undefined)</code>。</p>
<p>jQuery对象和DOM对象之间可以互相转化：</p>
<pre><code>var div = $('#abc'); // jQuery对象
var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
var another = $(divDom); // 重新把DOM包装为jQuery对象
</code></pre>
<p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用<code>$(aDomObject)</code>把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>
<h4 id="-tag-">按tag查找</h4>
<p>按tag查找只需要写上tag名称就可以了：</p>
<pre><code>var ps = $('p'); // 返回所有&lt;p&gt;节点
ps.length; // 数一数页面有多少个&lt;p&gt;节点
</code></pre>
<h4 id="-class-">按class查找</h4>
<p>按class查找注意在class名称前加一个<code>.</code>：</p>
<pre><code>var a = $('.red'); // 所有节点包含`class="red"`都将返回
// 例如:
// &lt;div class="red"&gt;...&lt;/div&gt;
// &lt;p class="green red"&gt;...&lt;/p&gt;
</code></pre>
<p>通常很多节点有多个class，我们可以查找同时包含<code>red</code>和<code>green</code>的节点：</p>
<pre><code>var a = $('.red.green'); // 注意没有空格！
// 符合条件的节点：
// &lt;div class="red green"&gt;...&lt;/div&gt;
// &lt;div class="blue green red"&gt;...&lt;/div&gt;
</code></pre>
<h4 id="-">按属性查找</h4>
<p>一个DOM节点除了<code>id</code>和<code>class</code>外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找：</p>
<pre><code>var email = $('[name=email]'); // 找出&lt;??? name="email"&gt;
var passwordInput = $('[type=password]'); // 找出&lt;??? type="password"&gt;
var a = $('[items="A B"]'); // 找出&lt;??? items="A B"&gt;
</code></pre>
<p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用前缀查找或者后缀查找：</p>
<pre><code>var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM
// 例如: name="icon-1", name="icon-2"
var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM
// 例如: name="startswith", name="endswith"
</code></pre>
<p>这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：</p>
<pre><code>var icons = $('[class^="icon-"]'); // 找出所有class包含至少一个以`icon-`开头的DOM
// 例如: class="icon-clock", class="abc icon-home"
</code></pre>
<h4 id="-">组合查找</h4>
<p>组合查找就是把上述简单选择器组合起来使用。如果我们查找<code>$('[name=email]')</code>，很可能把表单外的<code>&lt;div name="email"&gt;</code>也找出来，但我们只希望查找<code>&lt;input&gt;</code>，就可以这么写：</p>
<pre><code>var emailInput = $('input[name=email]'); // 不会找出&lt;div name="email"&gt;
</code></pre>
<p>同样的，根据tag和class来组合查找也很常见：</p>
<pre><code>var tr = $('tr.red'); // 找出&lt;tr class="red ..."&gt;...&lt;/tr&gt;
</code></pre>
<h4 id="-">多项选择器</h4>
<p>多项选择器就是把多个选择器用<code>,</code>组合起来一块选：</p>
<pre><code>$('p,div'); // 把&lt;p&gt;和&lt;div&gt;都选出来
$('p.red,p.green'); // 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来
</code></pre>
<p>要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class="red green"&gt;</code>不会被上面的<code>$('p.red,p.green')</code>选择两次。</p>
<h4 id="-">练习</h4>
<p>使用jQuery选择器分别选出指定元素：</p>
<ul>
<li><p>仅选择JavaScript</p>
</li>
<li><p>仅选择Erlang</p>
</li>
<li><p>选择JavaScript和Erlang</p>
</li>
<li><p>选择所有编程语言</p>
</li>
<li><p>选择名字input</p>
</li>
<li><p>选择邮件和名字input</p>
</li>
</ul>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-jquery"&gt;
    &lt;p id="para-1" class="color-red"&gt;JavaScript&lt;/p&gt;
    &lt;p id="para-2" class="color-green"&gt;Haskell&lt;/p&gt;
    &lt;p class="color-red color-green"&gt;Erlang&lt;/p&gt;
    &lt;p name="name" class="color-black"&gt;Python&lt;/p&gt;
    &lt;form class="test-form" target="_blank" action="#0" onsubmit="return false;"&gt;
        &lt;legend&gt;注册新用户&lt;/legend&gt;
        &lt;fieldset&gt;
            &lt;p&gt;&lt;label&gt;名字: &lt;input name="name"&gt;&lt;/label&gt;&lt;/p&gt;
            &lt;p&gt;&lt;label&gt;邮件: &lt;input name="email"&gt;&lt;/label&gt;&lt;/p&gt;
            &lt;p&gt;&lt;label&gt;口令: &lt;input name="password" type="password"&gt;&lt;/label&gt;&lt;/p&gt;
            &lt;p&gt;&lt;button type="submit"&gt;注册&lt;/button&gt;&lt;/p&gt;
        &lt;/fieldset&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>运行查看结果：</p>
<pre class="x-javascript">
'use strict';

var selected = null;
----
selected = ???;
----
// 高亮结果:
if (!(selected instanceof jQuery)) {
    return alert('不是有效的jQuery对象!');
}
$('#test-jquery').find('*').css('background-color', '');
selected.css('background-color', '#ffd351');
</pre>
<!-- HTML结构 -->
<div id="test-jquery">
    <p id="para-1" class="color-red">JavaScript</p>
    <p id="para-2" class="color-green">Haskell</p>
    <p class="color-red color-green">Erlang</p>
    <p name="name" class="color-black">Python</p>
    <form class="test-form" target="_blank" action="#0" onsubmit="return false;">
        <legend>注册新用户</legend>
        <fieldset>
            <p><label>名字: <input name="name"></label></p>
            <p><label>邮件: <input name="email"></label></p>
            <p><label>口令: <input name="password" type="password"></label></p>
            <p><button type="submit">注册</button></p>
        </fieldset>
    </form>
</div>
<h3>层级选择器</h3>
<p>除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。</p>
<p>因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h4 id="-descendant-selector-">层级选择器（Descendant Selector）</h4>
<p>如果两个DOM元素具有层级关系，就可以用<code>$('ancestor descendant')</code>来选择，层级之间用空格隔开。例如：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div class="testing"&gt;
    &lt;ul class="lang"&gt;
        &lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;
        &lt;li class="lang-python"&gt;Python&lt;/li&gt;
        &lt;li class="lang-lua"&gt;Lua&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>要选出JavaScript，可以用层级选择器：</p>
<pre><code>$('ul.lang li.lang-javascript'); // [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]
$('div.testing li.lang-javascript'); // [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]
</code></pre>
<p>因为<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>都是<code>&lt;li&gt;</code>的祖先节点，所以上面两种方式都可以选出相应的<code>&lt;li&gt;</code>节点。</p>
<p>要选择所有的<code>&lt;li&gt;</code>节点，用：</p>
<pre><code>$('ul.lang li');
</code></pre>
<p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p>
<p>例如：</p>
<pre><code>$('form[name=upload] input');
</code></pre>
<p>就把选择范围限定在<code>name</code>属性为<code>upload</code>的表单里。如果页面有很多表单，其他表单的<code>&lt;input&gt;</code>不会被选择。</p>
<p>多层选择也是允许的：</p>
<pre><code>$('form.test p input'); // 在form表单选择被&lt;p&gt;包含的&lt;input&gt;
</code></pre>
<h4 id="-child-selector-">子选择器（Child Selector）</h4>
<p>子选择器<code>$('parent&gt;child')</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子：</p>
<pre><code>$('ul.lang&gt;li.lang-javascript'); // 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]
$('div.testing&gt;li.lang-javascript'); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系
</code></pre>
<h4 id="-filter-">过滤器（Filter）</h4>
<p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：</p>
<pre><code>$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点

$('ul.lang li:first-child'); // 仅选出JavaScript
$('ul.lang li:last-child'); // 仅选出Lua
$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始
$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素
$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素
</code></pre>
<h4 id="-">表单相关</h4>
<p>针对表单元素，jQuery还有一组特殊的选择器：</p>
<ul>
<li><p><code>:input</code>：可以选择<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code>；</p>
</li>
<li><p><code>:file</code>：可以选择<code>&lt;input type="file"&gt;</code>，和<code>input[type=file]</code>一样；</p>
</li>
<li><p><code>:checkbox</code>：可以选择复选框，和<code>input[type=checkbox]</code>一样；</p>
</li>
<li><p><code>:radio</code>：可以选择单选框，和<code>input[type=radio]</code>一样；</p>
</li>
<li><p><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用<code>$('input:focus')</code>就可以选出；</p>
</li>
<li><p><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$('input[type=radio]:checked')</code>；</p>
</li>
<li><p><code>:enabled</code>：可以选择可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>
等，也就是没有灰掉的输入；</p>
</li>
<li><p><code>:disabled</code>：和<code>:enabled</code>正好相反，选择那些不能输入的。</p>
</li>
</ul>
<p>此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：</p>
<pre><code>$('div:visible'); // 所有可见的div
$('div:hidden'); // 所有隐藏的div
</code></pre>
<h4 id="-">练习</h4>
<p>针对如下HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;

&lt;div class="test-selector"&gt;
    &lt;ul class="test-lang"&gt;
        &lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;
        &lt;li class="lang-python"&gt;Python&lt;/li&gt;
        &lt;li class="lang-lua"&gt;Lua&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol class="test-lang"&gt;
        &lt;li class="lang-swift"&gt;Swift&lt;/li&gt;
        &lt;li class="lang-java"&gt;Java&lt;/li&gt;
        &lt;li class="lang-c"&gt;C&lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<p>选出相应的内容并观察效果：</p>
<pre class="x-javascript">
'use strict';
var selected = null;
----
// 分别选择所有语言，所有动态语言，所有静态语言，JavaScript，Lua，C等:
selected = ???
----
// 高亮结果:
if (!(selected instanceof jQuery)) {
    return alert('不是有效的jQuery对象!');
}
$('#test-jquery').find('*').css('background-color', '');
selected.css('background-color', '#ffd351');
</pre>
<div id="test-jquery" class="test-selector">
    <ul class="test-lang">
        <li class="lang-javascript">JavaScript</li>
        <li class="lang-python">Python</li>
        <li class="lang-lua">Lua</li>
    </ul>
    <ol class="test-lang">
        <li class="lang-swift">Swift</li>
        <li class="lang-java">Java</li>
        <li class="lang-c">C</li>
    </ol>
</div>
<h3>查找和过滤</h3>
<p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<p>最常见的查找是在某个节点的所有子节点中查找，使用<code>find()</code>方法，它本身又接收一个任意的选择器。例如如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul class="lang"&gt;
    &lt;li class="js dy"&gt;JavaScript&lt;/li&gt;
    &lt;li class="dy"&gt;Python&lt;/li&gt;
    &lt;li id="swift"&gt;Swift&lt;/li&gt;
    &lt;li class="dy"&gt;Scheme&lt;/li&gt;
    &lt;li name="haskell"&gt;Haskell&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>用<code>find()</code>查找：</p>
<pre><code>var ul = $('ul.lang'); // 获得&lt;ul&gt;
var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme
var swf = ul.find('#swift'); // 获得Swift
var hsk = ul.find('[name=haskell]'); // 获得Haskell
</code></pre>
<p>如果要从当前节点开始向上查找，使用<code>parent()</code>方法：</p>
<pre><code>var swf = $('#swift'); // 获得Swift
var parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;
var a = swf.parent('div.red'); // 从Swift的父节点开始向上查找，直到找到某个符合条件的节点并返回
</code></pre>
<p>对于位于同一层级的节点，可以通过<code>next()</code>和<code>prev()</code>方法，例如：</p>
<p>当我们已经拿到<code>Swift</code>节点后：</p>
<pre><code>var swift = $('#swift');

swift.next(); // Scheme
swift.next('[name=haskell]'); // Haskell，因为Haskell是后续第一个符合选择器条件的节点

swift.prev(); // Python
swift.prev('.js'); // JavaScript，因为JavaScript是往前第一个符合选择器条件的节点
</code></pre>
<h4 id="-">过滤</h4>
<p>和函数式编程的map、filter类似，jQuery对象也有类似的方法。</p>
<p><code>filter()</code>方法可以过滤掉不符合选择器条件的节点：</p>
<pre><code>var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme
</code></pre>
<p>或者传入一个函数，要特别注意函数内部的<code>this</code>被绑定为DOM对象，不是jQuery对象：</p>
<pre><code>var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
langs.filter(function () {
    return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点
}); // 拿到Swift, Scheme
</code></pre>
<p><code>map()</code>方法把一个jQuery对象包含的若干DOM节点转化为其他对象：</p>
<pre><code>var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var arr = langs.map(function () {
    return this.innerHTML;
}).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']
</code></pre>
<p>此外，一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉：</p>
<pre><code>var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')
var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')
var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致
</code></pre>
<h4 id="-">练习</h4>
<p>对于下面的表单：</p>
<pre><code>&lt;form id="test-form3" action="#0" onsubmit="return false;"&gt;
    &lt;p&gt;&lt;label&gt;Name: &lt;input name="name"&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Email: &lt;input name="email"&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Password: &lt;input name="password" type="password"&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;Gender: &lt;label&gt;&lt;input name="gender" type="radio" value="m" checked&gt; Male&lt;/label&gt; &lt;label&gt;&lt;input name="gender" type="radio" value="f"&gt; Female&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;City: &lt;select name="city"&gt;
        &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt;
        &lt;option value="SH"&gt;Shanghai&lt;/option&gt;
        &lt;option value="CD"&gt;Chengdu&lt;/option&gt;
        &lt;option value="XM"&gt;Xiamen&lt;/option&gt;
    &lt;/select&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre>
<p>输入值后，用jQuery获取表单的JSON字符串，key和value分别对应每个输入的name和相应的value，例如：<code>{"name":"Michael","email":...}</code></p>
<pre class="x-javascript">
'use strict';
var json = null;
----
json = ???;
----
// 显示结果:
if (typeof(json) === 'string') {
    alert(json);
}
else {
    alert('json变量不是string!');
}
</pre>
<form id="test-form4" action="#0" onsubmit="return false;">
    <p><label>Name: <input name="name"></label></p>
    <p><label>Email: <input name="email"></label></p>
    <p><label>Password: <input name="password" type="password"></label></p>
    <p>Gender: <label><input name="gender" type="radio" value="m" checked> Male</label> <label><input name="gender" type="radio" value="f"> Female</label></p>
    <p><label>City: <select name="city">
        <option value="BJ" selected>Beijing</option>
        <option value="SH">Shanghai</option>
        <option value="CD">Chengdu</option>
        <option value="XM">Xiamen</option>
    </select></label></p>
    <p><button type="submit">Submit</button></p>
</form>
<h2>操作DOM</h2>
<p>jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？</p>
<p>答案当然是操作对应的DOM节点啦！</p>
<p>回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！</p>
<h4 id="-text-html">修改Text和HTML</h4>
<p>jQuery对象的<code>text()</code>和<code>html()</code>方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul id="test-ul"&gt;
    &lt;li class="js"&gt;JavaScript&lt;/li&gt;
    &lt;li name="book"&gt;Java &amp;amp; JavaScript&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>分别获取文本和HTML：</p>
<pre><code>$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'
$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript'
</code></pre>
<p>如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用<code>text()</code>是获取文本，传入参数就变成设置文本，HTML也是类似操作，自己动手试试：</p>
<pre class="x-javascript">
'use strict';
var j1 = $('#test-ul li.js');
var j2 = $('#test-ul li[name=book]');
----
j1.html('&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;');
j2.text('JavaScript &amp; ECMAScript');
</pre>
<ul id="test-ul">
    <li class="js">JavaScript</li>
    <li name="book">Java &amp; JavaScript</li>
</ul>
<p>一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：</p>
<pre><code>$('#test-ul li').text('JS'); // 是不是两个节点都变成了JS？
</code></pre>
<p>所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：</p>
<pre><code>// 如果不存在id为not-exist的节点：
$('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello'
</code></pre>
<p>这意味着jQuery帮你免去了许多<code>if</code>语句。</p>
<h4 id="-css">修改CSS</h4>
<p>jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;ul id="test-css"&gt;
    &lt;li class="lang dy"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;
    &lt;li class="lang"&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt;
    &lt;li class="lang dy"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;
    &lt;li class="lang"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;
    &lt;li class="lang dy"&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>要高亮显示动态语言，调用jQuery对象的<code>css('name', 'value')</code>方法，我们用一行语句实现：</p>
<pre class="x-javascript">
'use strict';
----
$('#test-css li.dy&gt;span').css('background-color', '#ffd351').css('color', 'red');
</pre>
<ul id="test-css">
    <li class="lang dy"><span>JavaScript</span></li>
    <li class="lang"><span>Java</span></li>
    <li class="lang dy"><span>Python</span></li>
    <li class="lang"><span>Swift</span></li>
    <li class="lang dy"><span>Scheme</span></li>
</ul>
<p><em>注意</em>，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。</p>
<p>jQuery对象的<code>css()</code>方法可以这么用：</p>
<pre><code>var div = $('#test-div');
div.css('color'); // '#000033', 获取CSS属性
div.css('color', '#336699'); // 设置CSS属性
div.css('color', ''); // 清除CSS属性
</code></pre>
<p>为了和JavaScript保持一致，CSS属性可以用<code>'background-color'</code>和<code>'backgroundColor'</code>两种格式。</p>
<p><code>css()</code>方法将作用于DOM节点的<code>style</code>属性，具有最高优先级。如果要修改<code>class</code>属性，可以用jQuery提供的下列方法：</p>
<pre><code>var div = $('#test-div');
div.hasClass('highlight'); // false， class是否包含highlight
div.addClass('highlight'); // 添加highlight这个class
div.removeClass('highlight'); // 删除highlight这个class
</code></pre>
<p>练习：分别用<code>css()</code>方法和<code>addClass()</code>方法高亮显示JavaScript：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;style&gt;
.highlight {
    color: #dd1144;
    background-color: #ffd351;
}
&lt;/style&gt;

&lt;div id="test-highlight-css"&gt;
    &lt;ul&gt;
        &lt;li class="py"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;
        &lt;li class="js"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;
        &lt;li class="sw"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;
        &lt;li class="hk"&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<pre class="x-javascript">
'use strict';
----
var div = $('#test-highlight-css');
// TODO:
</pre>
<style>
.highlight {
    color: #dd1144;
    background-color: #ffd351;
}
</style>
<div id="test-highlight-css">
    <ul>
        <li class="py"><span>Python</span></li>
        <li class="js"><span>JavaScript</span></li>
        <li class="sw"><span>Swift</span></li>
        <li class="hk"><span>Haskell</span></li>
    </ul>
</div>
<h4 id="-dom">显示和隐藏DOM</h4>
<p>要隐藏一个DOM，我们可以设置CSS的<code>display</code>属性为<code>none</code>，利用<code>css()</code>方法就可以实现。不过，要显示这个DOM就需要恢复原有的<code>display</code>属性，这就得先记下来原有的<code>display</code>属性到底是<code>block</code>还是<code>inline</code>还是别的值。</p>
<p>考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供<code>show()</code>和<code>hide()</code>方法，我们不用关心它是如何修改<code>display</code>属性的，总之它能正常工作：</p>
<pre><code>var a = $('a[target=_blank]');
a.hide(); // 隐藏
a.show(); // 显示
</code></pre>
<p><em>注意</em>，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。</p>
<h4 id="-dom-">获取DOM信息</h4>
<p>利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：</p>
<pre><code>// 浏览器可视窗口大小:
$(window).width(); // 800
$(window).height(); // 600

// HTML文档大小:
$(document).width(); // 800
$(document).height(); // 3500

// 某个div的大小:
var div = $('#test-div');
div.width(); // 600
div.height(); // 300
div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效
div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效
</code></pre>
<p><code>attr()</code>和<code>removeAttr()</code>方法用于操作DOM节点的属性：</p>
<pre><code>// &lt;div id="test-div" name="Test" start="1"&gt;...&lt;/div&gt;
var div = $('#test-div');
div.attr('data'); // undefined, 属性不存在
div.attr('name'); // 'Test'
div.attr('name', 'Hello'); // div的name属性变为'Hello'
div.removeAttr('name'); // 删除name属性
div.attr('name'); // undefined
</code></pre>
<p><code>prop()</code>方法和<code>attr()</code>类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：</p>
<pre><code>&lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;
</code></pre>
<p>等价于：</p>
<pre><code>&lt;input id="test-radio" type="radio" name="test" checked="checked" value="1"&gt;
</code></pre>
<p><code>attr()</code>和<code>prop()</code>对于属性<code>checked</code>处理有所不同：</p>
<pre><code>var radio = $('#test-radio');
radio.attr('checked'); // 'checked'
radio.prop('checked'); // true
</code></pre>
<p><code>prop()</code>返回值更合理一些。不过，用<code>is()</code>方法判断更好：</p>
<pre><code>var radio = $('#test-radio');
radio.is(':checked'); // true
</code></pre>
<p>类似的属性还有<code>selected</code>，处理时最好用<code>is(':selected')</code>。</p>
<h4 id="-">操作表单</h4>
<p>对于表单元素，jQuery对象统一提供<code>val()</code>方法获取和设置对应的<code>value</code>属性：</p>
<pre><code>/*
    &lt;input id="test-input" name="email" value=""&gt;
    &lt;select id="test-select" name="city"&gt;
        &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt;
        &lt;option value="SH"&gt;Shanghai&lt;/option&gt;
        &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt;
    &lt;/select&gt;
    &lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;
*/
var
    input = $('#test-input'),
    select = $('#test-select'),
    textarea = $('#test-textarea');

input.val(); // 'test'
input.val('abc@example.com'); // 文本框的内容已变为abc@example.com

select.val(); // 'BJ'
select.val('SH'); // 选择框已变为Shanghai

textarea.val(); // 'Hello'
textarea.val('Hi'); // 文本区域已更新为'Hi'
</code></pre>
<p>可见，一个<code>val()</code>就统一了各种输入框的取值和赋值的问题。</p>
<h3>修改DOM结构</h3>
<p>直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>
<p>有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。</p>
<h4 id="-dom">添加DOM</h4>
<p>要添加新的DOM节点，除了通过jQuery的<code>html()</code>这种暴力方法外，还可以用<code>append()</code>方法，例如：</p>
<pre><code>&lt;div id="test-div"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>如何向列表新增一个语言？首先要拿到<code>&lt;ul&gt;</code>节点：</p>
<pre><code>var ul = $('#test-div&gt;ul');
</code></pre>
<p>然后，调用<code>append()</code>传入HTML片段：</p>
<pre><code>ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;');
</code></pre>
<p>除了接受字符串，<code>append()</code>还可以传入原始的DOM对象，jQuery对象和函数对象：</p>
<pre><code>// 创建DOM对象:
var ps = document.createElement('li');
ps.innerHTML = '&lt;span&gt;Pascal&lt;/span&gt;';
// 添加DOM对象:
ul.append(ps);

// 添加jQuery对象:
ul.append($('#scheme'));

// 添加函数对象:
ul.append(function (index, html) {
    return '&lt;li&gt;&lt;span&gt;Language - ' + index + '&lt;/span&gt;&lt;/li&gt;';
});
</code></pre>
<p>传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的<code>append()</code>可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。</p>
<p><code>append()</code>把DOM添加到最后，<code>prepend()</code>则把DOM添加到最前。</p>
<p>另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用<code>append()</code>，你可以移动一个DOM节点。</p>
<p>如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用<code>after()</code>方法：</p>
<pre><code>var js = $('#test-div&gt;ul&gt;li:first-child');
js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;');
</code></pre>
<p>也就是说，同级节点可以用<code>after()</code>或者<code>before()</code>方法。</p>
<h4 id="-">删除节点</h4>
<p>要删除DOM节点，拿到jQuery对象后直接调用<code>remove()</code>方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：</p>
<pre><code>var li = $('#test-div&gt;ul&gt;li');
li.remove(); // 所有&lt;li&gt;全被删除
</code></pre>
<h4 id="-">练习</h4>
<p>除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-div"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;
        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<pre class="x-javascript">
'use strict';
----
----
// 测试:
;(function () {
    var s = $('#test-div&gt;ul&gt;li').map(function () {
        return $(this).text();
    }).get().join(',');
    if (s === 'JavaScript,Lua,Pascal,Python,Ruby,Swift') {
        alert('测试通过!');
    } else {
        alert('测试失败: ' + s);
    }
})();
</pre>
<div id="test-div">
    <ul>
        <li><span>JavaScript</span></li>
        <li><span>Python</span></li>
        <li><span>Swift</span></li>
    </ul>
</div>
<h2>事件</h2>
<p>因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个<code>click</code>事件：</p>
<script>
$(function () {
    $('#test-link').click(function () {
        alert('Hello!');
    });
});
</script>
<pre><code>/* HTML:
 *
 * &lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;
 *
 */

// 获取超链接的jQuery对象:
var a = $('#test-link');
a.on('click', function () {
    alert('Hello!');
});
</code></pre>
<p>实测：<a id="test-link" href="#0">点我试试</a></p>
<p><code>on</code>方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>
<p>另一种更简化的写法是直接调用<code>click()</code>方法：</p>
<pre><code>a.click(function () {
    alert('Hello!');
});
</code></pre>
<p>两者完全等价。我们通常用后面的写法。</p>
<p>jQuery能够绑定的事件主要包括：</p>
<h4 id="-">鼠标事件</h4>
<p>click: 鼠标单击时触发；
dblclick：鼠标双击时触发；
mouseenter：鼠标进入时触发；
mouseleave：鼠标移出时触发；
mousemove：鼠标在DOM内部移动时触发；
hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。</p>
<h4 id="-">键盘事件</h4>
<p>键盘事件仅作用在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>。</p>
<p>keydown：键盘按下时触发；
keyup：键盘松开时触发；
keypress：按一次键后触发。</p>
<h4 id="-">其他事件</h4>
<p>focus：当DOM获得焦点时触发；
blur：当DOM失去焦点时触发；
change：当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>或<code>&lt;textarea&gt;</code>的内容改变时触发；
submit：当<code>&lt;form&gt;</code>提交时触发；
ready：当页面被载入并且DOM树完成初始化后触发。</p>
<p>其中，<code>ready</code>仅作用于<code>document</code>对象。由于<code>ready</code>事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个<code>&lt;form&gt;</code>表单绑定<code>submit</code>事件，下面的代码没有预期的效果：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        // 代码有误:
        $('#testForm).on('submit', function () {
            alert('submit!');
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="testForm"&gt;
        ...
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<p>因为JavaScript在此执行的时候，<code>&lt;form&gt;</code>尚未载入浏览器，所以<code>$('#testForm)</code>返回<code>[]</code>，并没有绑定事件到任何DOM上。</p>
<p>所以我们自己的初始化代码必须放到<code>document</code>对象的<code>ready</code>事件中，保证DOM已完成初始化：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        $(document).on('ready', function () {
            $('#testForm).on('submit', function () {
                alert('submit!');
            });
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id="testForm"&gt;
        ...
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
<p>这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。</p>
<p>由于<code>ready</code>事件使用非常普遍，所以可以这样简化：</p>
<pre><code>$(document).ready(function () {
    // on('submit', function)也可以简化:
    $('#testForm).submit(function () {
        alert('submit!');
    });
});
</code></pre>
<p>甚至还可以再简化为：</p>
<pre><code>$(function () {
    // init...
});
</code></pre>
<p>上面的这种写法最为常见。如果你遇到<code>$(function () {...})</code>的形式，牢记这是<code>document</code>对象的<code>ready</code>事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行：</p>
<pre><code>$(function () {
    console.log('init A...');
});
$(function () {
    console.log('init B...');
});
$(function () {
    console.log('init C...');
});
</code></pre>
<h4 id="-">事件参数</h4>
<p>有些事件，如<code>mousemove</code>和<code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入<code>Event</code>对象作为参数，可以从<code>Event</code>对象上获取到更多的信息：</p>
<pre><code>$(function () {
    $('#testMouseMoveDiv').mousemove(function (e) {
        $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
    });
});
</code></pre>
<script>
$(function () {
    $('#testMouseMoveDiv').mousemove(function (e) {
        $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
    });
});
</script>
<p>效果实测：</p>
<p></p>
<p>mousemove: <span id="testMouseMoveSpan"></span></p>
<div id="testMouseMoveDiv" style="display: block; width: 300px; height: 120px; border: 1px solid #ccc;">在此区域移动鼠标试试</div>
<h4 id="-">取消绑定</h4>
<p>一个已被绑定的事件可以解除绑定，通过<code>off('click', function)</code>实现：</p>
<pre><code>function hello() {
    alert('hello!');
}

a.click(hello); // 绑定事件

// 10秒钟后解除绑定:
setTimeout(function () {
    a.off('click', hello);
}, 10000);
</code></pre>
<p>需要特别注意的是，下面这种写法是无效的：</p>
<pre><code>// 绑定事件:
a.click(function () {
    alert('hello!');
});

// 解除绑定:
a.off('click', function () {
    alert('hello!');
});
</code></pre>
<p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个<em>不同</em>的函数对象，<code>off('click', function () {...})</code>无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用<code>off('click')</code>一次性移除已绑定的<code>click</code>事件的所有处理函数。</p>
<p>同理，无参数调用<code>off()</code>一次性移除已绑定的所有类型的事件处理函数。</p>
<h4 id="-">事件触发条件</h4>
<p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：</p>
<pre><code>var input = $('#test-input');
input.change(function () {
    console.log('changed...');
});
</code></pre>
<p>当用户在文本框中输入时，就会触发<code>change</code>事件。但是，如果用JavaScript代码去改动文本框的值，将<strong><em>不会</em></strong>触发<code>change</code>事件：</p>
<pre><code>var input = $('#test-input');
input.val('change it!'); // 无法触发change事件
</code></pre>
<p>有些时候，我们希望用代码触发<code>change</code>事件，可以直接调用无参数的<code>change()</code>方法来触发该事件：</p>
<pre><code>var input = $('#test-input');
input.val('change it!');
input.change(); // 触发change事件
</code></pre>
<p><code>input.change()</code>相当于<code>input.trigger('change')</code>，它是<code>trigger()</code>方法的简写。</p>
<p>为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>
<h4 id="-">浏览器安全限制</h4>
<p>在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，<code>window.open()</code>函数：</p>
<pre><code>// 无法弹出新窗口，将被浏览器屏蔽:
$(function () {
    window.open('/');
});
</code></pre>
<p>这些“敏感代码”只能由用户操作来触发：</p>
<pre><code>var button1 = $('#testPopupButton1');
var button2 = $('#testPopupButton2');

function popupTestWindow() {
    window.open('/');
}

button1.click(function () {
    popupTestWindow();
});

button2.click(function () {
    // 不立刻执行popupTestWindow()，100毫秒后执行:
    setTimeout(popupTestWindow, 100);
});
</code></pre>
<p>当用户点击<code>button1</code>时，<code>click</code>事件被触发，由于<code>popupTestWindow()</code>在<code>click</code>事件处理函数内执行，这是浏览器允许的，而<code>button2</code>的<code>click</code>事件并未立刻执行<code>popupTestWindow()</code>，延迟执行的<code>popupTestWindow()</code>将被浏览器拦截。</p>
<script>
$(function () {
    var button1 = $('#testPopupButton1');
    var button2 = $('#testPopupButton2');

    function popupTestWindow() {
        window.open('?t=' + new Date().getTime(), 'popupWindow', 'width=400&height=300');
    }

    button1.click(function () {
        popupTestWindow();
    });

    button2.click(function () {
        setTimeout(popupTestWindow, 100);
    });
});
</script>
<p>效果实测：</p>
<button id="testPopupButton1" type="button" class="uk-button">Button 1</button>   
<button id="testPopupButton2" type="button" class="uk-button">Button 2</button>
<h4 id="-">练习</h4>
<p>对如下的Form表单：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;form id="test-form5" action="test"&gt;
    &lt;legend&gt;请选择想要学习的编程语言：&lt;/legend&gt;
    &lt;fieldset&gt;
        &lt;p&gt;&lt;label class="selectAll"&gt;&lt;input type="checkbox"&gt; &lt;span class="selectAll"&gt;全选&lt;/span&gt;&lt;span class="deselectAll"&gt;全不选&lt;/span&gt;&lt;/label&gt; &lt;a href="#0" class="invertSelect"&gt;反选&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;&lt;input type="checkbox" name="lang" value="javascript"&gt; JavaScript&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;&lt;input type="checkbox" name="lang" value="python"&gt; Python&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;&lt;input type="checkbox" name="lang" value="ruby"&gt; Ruby&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;&lt;input type="checkbox" name="lang" value="haskell"&gt; Haskell&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;label&gt;&lt;input type="checkbox" name="lang" value="scheme"&gt; Scheme&lt;/label&gt;&lt;/p&gt;
        &lt;p&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/p&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<p>绑定合适的事件处理函数，实现以下逻辑：</p>
<p>当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；</p>
<p>当用户去掉“全不选”时，自动不选中所有语言；</p>
<p>当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；</p>
<p>当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；</p>
<p>当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。</p>
<pre class="x-javascript">
'use strict';

var
    form = $('#test-form5'),
    langs = form.find('[name=lang]'),
    selectAll = form.find('label.selectAll :checkbox'),
    selectAllLabel = form.find('label.selectAll span.selectAll'),
    deselectAllLabel = form.find('label.selectAll span.deselectAll'),
    invertSelect = form.find('a.invertSelect');

// 重置初始化状态:
form.find('*').show().off();
form.find(':checkbox').prop('checked', false).off();
deselectAllLabel.hide();
// 拦截form提交事件:
form.off().submit(function (e) {
    e.preventDefault();
    alert(form.serialize());
});
----
// TODO:绑定事件
----
// 测试:
alert('请测试功能是否正常。');
</pre>
<form id="test-form6" action="test">
    <legend>请选择想要学习的编程语言：</legend>
    <fieldset>
        <p><label class="selectAll"><input type="checkbox"> <span class="selectAll">全选</span><span class="deselectAll">全不选</span></label> <a href="#0" class="invertSelect">反选</a></p>
        <p><label><input type="checkbox" name="lang" value="javascript"> JavaScript</label></p>
        <p><label><input type="checkbox" name="lang" value="python"> Python</label></p>
        <p><label><input type="checkbox" name="lang" value="ruby"> Ruby</label></p>
        <p><label><input type="checkbox" name="lang" value="haskell"> Haskell</label></p>
        <p><label><input type="checkbox" name="lang" value="scheme"> Scheme</label></p>
        <p><button type="submit">Submit</button></p>
    </fieldset>
</form>
<h2>动画</h2>
<p>用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。</p>
<p>但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！</p>
<p>让我们先来看看jQuery内置的几种动画样式：</p>
<h4 id="show-hide">show / hide</h4>
<p>直接以无参数形式调用<code>show()</code>和<code>hide()</code>，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画：</p>
<pre><code>var div = $('#test-show-hide');
div.hide(3000); // 在3秒钟内逐渐消失
</code></pre>
<p>时间以毫秒为单位，但也可以是<code>'slow'</code>，<code>'fast'</code>这些字符串：</p>
<pre><code>var div = $('#test-show-hide');
div.show('slow'); // 在0.6秒钟内逐渐显示
</code></pre>
<p><code>toggle()</code>方法则根据当前状态决定是<code>show()</code>还是<code>hide()</code>。</p>
<p>效果实测：</p>
<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0">
    <div style="padding: 10px 0">
        <button class="uk-button" onclick="$('#test-show-hide').hide('slow');">hide('slow')</button>
        <button class="uk-button" onclick="$('#test-show-hide').show('slow');">show('slow')</button>
        <button class="uk-button" onclick="$('#test-show-hide').toggle('slow');">toggle('slow')</button>
    </div>
    <div style="height: 128px;">
        <div id="test-show-hide" style="width: 128px; height: 128px; background-color: #ccc; background-image: url(./files/404.png)"></div>
    </div>
</div>
<h4 id="slideup-slidedown">slideUp / slideDown</h4>
<p>你可能已经看出来了，<code>show()</code>和<code>hide()</code>是从左上角逐渐展开或收缩的，而<code>slideUp()</code>和<code>slideDown()</code>则是在垂直方向逐渐展开或收缩的。</p>
<p><code>slideUp()</code>把一个可见的DOM元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code>相反，而<code>slideToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<pre><code>var div = $('#test-slide');
div.slideUp(3000); // 在3秒钟内逐渐向上消失
</code></pre>
<p>效果实测：</p>
<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0">
    <div style="padding: 10px 0">
        <button class="uk-button" onclick="$('#test-slide').slideUp('slow');">slideUp('slow')</button>
        <button class="uk-button" onclick="$('#test-slide').slideDown('slow');">slideDown('slow')</button>
        <button class="uk-button" onclick="$('#test-slide').slideToggle('slow');">slideToggle('slow')</button>
    </div>
    <div style="height: 128px;">
        <div id="test-slide" style="width: 128px; height: 128px; background-color: #ccc; background-image: url(./files/404.png)"></div>
    </div>
</div>
<h4 id="fadein-fadeout">fadeIn / fadeOut</h4>
<p><code>fadeIn()</code>和<code>fadeOut()</code>的动画效果是淡入淡出，也就是通过不断设置DOM元素的<code>opacity</code>属性来实现，而<code>fadeToggle()</code>则根据元素是否可见来决定下一步动作：</p>
<pre><code>var div = $('#test-fade');
div.fadeOut('slow'); // 在0.6秒内淡出
</code></pre>
<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0">
    <div style="padding: 10px 0">
        <button class="uk-button" onclick="$('#test-fade').fadeOut('slow');">fadeOut('slow')</button>
        <button class="uk-button" onclick="$('#test-fade').fadeIn('slow');">fadeIn('slow')</button>
        <button class="uk-button" onclick="$('#test-fade').fadeToggle('slow');">fadeToggle('slow')</button>
    </div>
    <div style="height: 128px;">
        <div id="test-fade" style="width: 128px; height: 128px; background-color: #ccc; background-image: url(./files/404.png)"></div>
    </div>
</div>
<h4 id="-">自定义动画</h4>
<p>如果上述动画效果还不能满足你的要求，那就祭出最后大招：<code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：</p>
<pre><code>var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000); // 在3秒钟内CSS过渡到设定值
</code></pre>
<p><code>animate()</code>还可以再传入一个函数，当动画结束时，该函数将被调用：</p>
<pre><code>var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000, function () {
    console.log('动画已结束');
    // 恢复至初始状态:
    $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
});
</code></pre>
<p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<p>有了<code>animate()</code>，你就可以实现各种自定义动画效果了：</p>
<script>
function customAnimate() {
    $('#test-animate').animate({
        opacity: 0.25,
        width: '256px',
        height: '256px'
    }, 3000, function() {
        $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
    });
}
</script>
<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0">
    <div style="padding: 10px 0">
        <button class="uk-button" onclick="customAnimate();">animate()</button>
    </div>
    <div style="height: 256px;">
        <div id="test-animate" style="width: 128px; height: 128px; background-color: #ccc; background-image: url(./files/404.png); background-repeat: no-repeat; background-position: center center;"></div>
    </div>
</div>
<h4 id="-">串行动画</h4>
<p>jQuery的动画效果还可以串行执行，通过<code>delay()</code>方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：</p>
<pre><code>var div = $('#test-animates');
// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小
div.slideDown(2000)
   .delay(1000)
   .animate({
       width: '256px',
       height: '256px'
   }, 2000)
   .delay(1000)
   .animate({
       width: '128px',
       height: '128px'
   }, 2000);
}
&lt;/script&gt;
</code></pre>
<p>因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<p>效果实测：</p>
<script>
function animates() {
    $('#test-animates')
        .hide()
        .slideDown(2000)
        .delay(1000)
        .animate({
            width: '256px',
            height: '256px'
        }, 2000)
        .delay(1000)
        .animate({
            width: '128px',
            height: '128px'
        }, 2000);
}
</script>
<div style="border: 1px solid #ccc; padding: 10px; margin: 10px 0">
    <div style="padding: 10px 0">
        <button class="uk-button" onclick="animates();">animate</button>
    </div>
    <div style="height: 256px;">
        <div id="test-animates" style="width: 128px; height: 128px; background-color: #ccc; background-image: url(./files/404.png); background-repeat: no-repeat; background-position: center center;"></div>
    </div>
</div>
<h4 id="-">为什么有的动画没有效果</h4>
<p>你可能会遇到，有的动画如<code>slideUp()</code>根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如<code>height</code>从<code>100px</code>逐渐变为<code>0</code>。但是很多不是block性质的DOM元素，对它们设置<code>height</code>根本就不起作用，所以动画也就没有效果。</p>
<p>此外，jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果。这种情况下可以使用CSS3的<code>transition</code>实现动画效果。</p>
<h4 id="-">练习</h4>
<p>在执行删除操作时，给用户显示一个动画比直接调用<code>remove()</code>要更好。请在表格删除一行的时候添加一个淡出的动画效果：</p>
<pre>
<code class="x-javascript">
'use strict';

function deleteFirstTR() {
    var tr = $('#test-table&gt;tbody&gt;tr:visible').first();
----
----
}

deleteFirstTR();
</code>
</pre>
<script>
$(function () {
    var trs = [['Bart Simpson', 'bart.s@primary.school', 'Springfield', 'Active'],
               ['Michael Scofield', 'm.scofield@escape.org', 'Fox River', 'Locked'],
               ['Optimus Prime', 'prime@cybertron.org', 'Cybertron', 'Active'],
               ['Peter Parker', 'spider@movie.org', 'New York', 'Active'],
               ['Thor Odinson', 'thor@asgard.org', 'Asgard', 'Active']];
    var tbody = $('#test-table>tbody');
    var i;
    for (i=0; i < trs.length; i++) {
        tbody.append('<tr><td>' + trs[i].join('</td><td>') + '</td></tr>');
    }
    i = 0;
    $('#test-add-button').click(function () {
        if (i>=trs.length) {
            i = 0;
        }
        tbody.append('<tr><td>' + trs[i].join('</td><td>') + '</td></tr>');
        i ++;
    });
});
</script>
<table id="test-table" class="uk-table">
    <thead>
        <tr>
            <th>Name</th>
            <th>Email</th>
            <th>Address</th>
            <th>Status</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>
<button id="test-add-button" class="uk-button"><i class="uk-icon-plus"></i> Add</button>
<h2>AJAX</h2>
<p>用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。</p>
<p>用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。</p>
<h4 id="ajax">ajax</h4>
<p>jQuery在全局对象<code>jQuery</code>（也就是<code>$</code>）绑定了<code>ajax()</code>函数，可以处理AJAX请求。<code>ajax(url, settings)</code>函数需要接收一个URL和一个可选的<code>settings</code>对象，常用的选项如下：</p>
<ul>
<li><p>async：是否异步执行AJAX请求，默认为<code>true</code>，千万不要指定为<code>false</code>；</p>
</li>
<li><p>method：发送的Method，缺省为<code>'GET'</code>，可指定为<code>'POST'</code>、<code>'PUT'</code>等；</p>
</li>
<li><p>contentType：发送POST请求的格式，默认值为<code>'application/x-www-form-urlencoded; charset=UTF-8'</code>，也可以指定为<code>text/plain</code>、<code>application/json</code>；</p>
</li>
<li><p>data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；</p>
</li>
<li><p>headers：发送的额外的HTTP头，必须是一个object；</p>
</li>
<li><p>dataType：接收的数据格式，可以指定为<code>'html'</code>、<code>'xml'</code>、<code>'json'</code>、<code>'text'</code>等，缺省情况下根据响应的<code>Content-Type</code>猜测。</p>
</li>
</ul>
<p>下面的例子发送一个GET请求，并返回一个JSON格式的数据：</p>
<pre><code>var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
});
// 请求已经发送了
</code></pre>
<p>不过，如何用回调函数处理返回的数据和出错时的响应呢？</p>
<p>还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：</p>
<pre class="x-javascript">
'use strict';

function ajaxLog(s) {
    var txt = $('#test-response-text');
    txt.val(txt.val() + '\n' + s);
}

$('#test-response-text').val('');
----
var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
}).done(function (data) {
    ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));
}).fail(function (xhr, status) {
    ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);
}).always(function () {
    ajaxLog('请求完成: 无论成功或失败都会调用');
});
</pre>
<textarea id="test-response-text" rows="10" style="width: 90%; margin: 15px 0; resize: none;">
响应结果：
</textarea>
<h4 id="get">get</h4>
<p>对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了<code>get()</code>方法，可以这么写：</p>
<pre><code>var jqxhr = $.get('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
</code></pre>
<p>第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：</p>
<pre><code>/path/to/resource?name=Bob%20Lee&amp;check=1
</code></pre>
<p>这样我们就不用关心如何用URL编码并构造一个query string了。</p>
<h4 id="post">post</h4>
<p><code>post()</code>和<code>get()</code>类似，但是传入的第二个参数默认被序列化为<code>application/x-www-form-urlencoded</code>：</p>
<pre><code>var jqxhr = $.post('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
</code></pre>
<p>实际构造的数据<code>name=Bob%20Lee&amp;check=1</code>作为POST的body被发送。</p>
<h4 id="getjson">getJSON</h4>
<p>由于JSON用得越来越普遍，所以jQuery也提供了<code>getJSON()</code>方法来快速通过GET获取一个JSON对象：</p>
<pre><code>var jqxhr = $.getJSON('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
}).done(function (data) {
    // data已经被解析为JSON对象了
});
</code></pre>
<h4 id="-">安全限制</h4>
<p>jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。</p>
<p>如果需要使用JSONP，可以在<code>ajax()</code>中设置<code>jsonp: 'callback'</code>，让jQuery实现JSONP跨域加载数据。</p>
<p>关于跨域的设置请参考<a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997647015f03abc1bb5f46129a7526292a12ab26000">浏览器</a> - <a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">AJAX</a>一节中CORS的设置。</p>
<h2>扩展</h2>
<p>当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现：</p>
<pre><code>$('span.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');

$('p a.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');
</code></pre>
<p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个<code>highlight()</code>方法？</p>
<pre><code>$('span.hl').highlight();

$('p a.hl').highlight();
</code></pre>
<p>答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。</p>
<h4 id="-jquery-">编写jQuery插件</h4>
<p>给jQuery对象绑定一个新方法是通过扩展<code>$.fn</code>对象实现的。让我们来编写第一个扩展——<code>highlight1()</code>：</p>
<script>
$.fn.highlight1 = function () {
    this.css('backgroundColor', '#fffceb').css('color', '#d85030');
    return this;
}
</script>
<pre><code>$.fn.highlight1 = function () {
    // this已绑定为当前jQuery对象:
    this.css('backgroundColor', '#fffceb').css('color', '#d85030');
    return this;
}
</code></pre>
<p>注意到函数内部的<code>this</code>在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。</p>
<p>对于如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-highlight1"&gt;
    &lt;p&gt;什么是&lt;span&gt;jQuery&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;jQuery&lt;/span&gt;是目前最流行的&lt;span&gt;JavaScript&lt;/span&gt;库。&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>来测试一下<code>highlight1()</code>的效果：</p>
<pre class="x-javascript">
'use strict';
----
$('#test-highlight1 span').highlight1();
</pre>
<div id="test-highlight1" style="border: 1px solid #ccc; margin: 15px 0; padding: 15px;">
    <p>什么是<span>jQuery</span></p>
    <p><span>jQuery</span>是目前最流行的<span>JavaScript</span>库。</p>
</div>
<p>细心的童鞋可能发现了，为什么最后要<code>return this;</code>？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：</p>
<pre><code>$('span.hl').highlight1().slideDown();
</code></pre>
<p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>
<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？</p>
<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的<code>highlight2()</code>：</p>
<script>
$.fn.highlight2 = function (options) {
    var bgcolor = options && options.backgroundColor || '#fffceb';
    var color = options && options.color || '#d85030';
    this.css('backgroundColor', bgcolor).css('color', color);
    return this;
}
</script>
<pre><code>$.fn.highlight2 = function (options) {
    // 要考虑到各种情况:
    // options为undefined
    // options只有部分key
    var bgcolor = options &amp;&amp; options.backgroundColor || '#fffceb';
    var color = options &amp;&amp; options.color || '#d85030';
    this.css('backgroundColor', bgcolor).css('color', color);
    return this;
}
</code></pre>
<p>对于如下HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-highlight2"&gt;
    &lt;p&gt;什么是&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;可以用来扩展&lt;span&gt;jQuery&lt;/span&gt;的功能。&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>来实测一下带参数的<code>highlight2()</code>：</p>
<pre class="x-javascript">
'use strict';
----
$('#test-highlight2 span').highlight2({
    backgroundColor: '#00a8e6',
    color: '#ffffff'
});
</pre>
<div id="test-highlight2" style="border: 1px solid #ccc; margin: 15px 0; padding: 15px;">
    <p>什么是<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>可以用来扩展<span>jQuery</span>的功能。</p>
</div>
<p>对于默认值的处理，我们用了一个简单的<code>&amp;&amp;</code>和<code>||</code>短路操作符，总能得到一个有效的值。</p>
<p>另一种方法是使用jQuery提供的辅助方法<code>$.extend(target, obj1, obj2, ...)</code>，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高：</p>
<pre><code>// 把默认值和用户传入的options合并到对象{}中并返回:
var opts = $.extend({}, {
    backgroundColor: '#00a8e6',
    color: '#ffffff'
}, options);
</code></pre>
<p>紧接着用户对<code>highlight2()</code>提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的<code>highlight2()</code>？</p>
<p>也就是说，我们设定的默认值应该能允许用户修改。</p>
<p>那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是<code>$.fn.highlight2</code>这个函数对象本身。</p>
<p>于是最终版的<code>highlight()</code>终于诞生了：</p>
<script>
$.fn.highlight = function (options) {
    var opts = $.extend({}, $.fn.highlight.defaults, options);
    this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
    return this;
}

$.fn.highlight.defaults = {
    color: '#d85030',
    backgroundColor: '#fff8de'
}
</script>
<pre><code>$.fn.highlight = function (options) {
    // 合并默认值和用户设定值:
    var opts = $.extend({}, $.fn.highlight.defaults, options);
    this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
    return this;
}

// 设定默认值:
$.fn.highlight.defaults = {
    color: '#d85030',
    backgroundColor: '#fff8de'
}
</code></pre>
<p>这次用户终于满意了。用户使用时，只需一次性设定默认值：</p>
<pre><code>$.fn.highlight.defaults.color = '#fff';
$.fn.highlight.defaults.backgroundColor = '#000';
</code></pre>
<p>然后就可以非常简单地调用<code>highlight()</code>了。</p>
<p>对如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-highlight"&gt;
    &lt;p&gt;如何编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;，要设置&lt;span&gt;默认值&lt;/span&gt;，并允许用户修改&lt;span&gt;默认值&lt;/span&gt;，或者运行时传入&lt;span&gt;其他值&lt;/span&gt;。&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>实测一下修改默认值的效果：</p>
<pre class="x-javascript">
'use strict';
----
$.fn.highlight.defaults.color = '#659f13';
$.fn.highlight.defaults.backgroundColor = '#f2fae3';

$('#test-highlight p:first-child span').highlight();

$('#test-highlight p:last-child span').highlight({
    color: '#dd1144'
});
</pre>
<div id="test-highlight" style="border: 1px solid #ccc; margin: 15px 0; padding: 15px;">
    <p>如何编写<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>，要设置<span>默认值</span>，并允许用户修改<span>默认值</span>，或者运行时传入<span>其他值</span>。</p>
</div>
<p>最终，我们得出编写一个jQuery插件的原则：</p>
<ol>
<li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要<code>return this;</code>以支持链式调用；</li>
<li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ol>
<h4 id="-">针对特定元素的扩展</h4>
<p>我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如<code>submit()</code>方法只能针对<code>form</code>。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？</p>
<p>还记得jQuery的选择器支持<code>filter()</code>方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。</p>
<p>举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？</p>
<p>先写出用户调用的代码：</p>
<pre><code>$('#main a').external();
</code></pre>
<p>然后按照上面的方法编写一个<code>external</code>扩展：</p>
<script>
$.fn.external = function () {
    return this.filter('a').each(function () {
        var a = $(this);
        var url = a.attr('href');
        if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
            a.attr('href', '#0')
             .removeAttr('target')
             .append(' <i class="uk-icon-external-link"></i>')
             .click(function () {
                if(confirm('你确定要前往' + url + '？')) {
                    window.open(url);
                }
            });
        }
    });
}
</script>
<pre><code>$.fn.external = function () {
    // return返回的each()返回结果，支持链式调用:
    return this.filter('a').each(function () {
        // 注意: each()内部的回调函数的this绑定为DOM本身!
        var a = $(this);
        var url = a.attr('href');
        if (url &amp;&amp; (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
            a.attr('href', '#0')
             .removeAttr('target')
             .append(' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;')
             .click(function () {
                if(confirm('你确定要前往' + url + '？')) {
                    window.open(url);
                }
            });
        }
    });
}
</code></pre>
<p>对如下的HTML结构：</p>
<pre><code>&lt;!-- HTML结构 --&gt;
&lt;div id="test-external"&gt;
    &lt;p&gt;如何学习&lt;a href="http://jquery.com"&gt;jQuery&lt;/a&gt;？&lt;/p&gt;
    &lt;p&gt;首先，你要学习&lt;a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000"&gt;JavaScript&lt;/a&gt;，并了解基本的&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML"&gt;HTML&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>实测外链效果：</p>
<pre class="x-javascript">
'use strict';
----
$('#test-external a').external();
</pre>
<div id="test-external" style="border: 1px solid #ccc; margin: 15px 0; padding: 15px;">
<p>如何学习<a href="http://jquery.com">jQuery</a>？</p>
    <p>首先，你要学习<a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">JavaScript</a>，并了解基本的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a>。</p>
</div>
<h4 id="-">小结</h4>
<p>扩展jQuery对象的功能十分简单，但是我们要遵循jQuery的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和jQuery本身的方法没有什么区别。</p>
<h1>underscore</h1>
<p>前面我们已经讲过了，JavaScript是函数式编程语言，支持高阶函数和闭包。函数式编程非常强大，可以写出非常简洁的代码。例如<code>Array</code>的<code>map()</code>和<code>filter()</code>方法：</p>
<pre><code>'use strict';
var a1 = [1, 4, 9, 16];
var a2 = a1.map(Math.sqrt); // [1, 2, 3, 4]
var a3 = a2.filter((x) =&gt; { return x % 2 === 0; }); // [2, 4]
</code></pre>
<p>现在问题来了，<code>Array</code>有<code>map()</code>和<code>filter()</code>方法，可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？</p>
<p>方法一，自己把这些方法添加到<code>Array.prototype</code>中，然后给<code>Object.prototype</code>也加上<code>mapObject()</code>等类似的方法。</p>
<p>方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现<code>map()</code>、<code>filter()</code>这些操作。</p>
<p>我们采用方法二，选择的第三方库就是underscore。</p>
<p>正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。</p>
<p>jQuery在加载时，会把自身绑定到唯一的全局变量<code>$</code>上，underscore与其类似，会把自身绑定到唯一的全局变量<code>_</code>上，这也是为啥它的名字叫underscore的原因。</p>
<p>用underscore实现<code>map()</code>操作如下：</p>
<pre><code>'use strict';
_.map([1, 2, 3], (x) =&gt; x * x); // [1, 4, 9]
</code></pre>
<p>咋一看比直接用<code>Array.map()</code>要麻烦一点，可是underscore的<code>map()</code>还可以作用于Object：</p>
<pre><code>'use strict';
_.map({ a: 1, b: 2, c: 3 }, (v, k) =&gt; k + '=' + v); // ['a=1', 'b=2', 'c=3']
</code></pre>
<p>后面我们会详细介绍underscore提供了一系列函数式接口。</p>
<h2>Collections</h2>
<p>underscore为集合类对象提供了一致的接口。集合类是指Array和Object，暂不支持Map和Set。</p>
<h4 id="map-filter">map/filter</h4>
<p>和<code>Array</code>的<code>map()</code>与<code>filter()</code>类似，但是underscore的<code>map()</code>和<code>filter()</code>可以作用于Object。当作用于Object时，传入的函数为<code>function (value, key)</code>，第一个参数接收value，第二个参数接收key：</p>
<pre class="x-javascript">
'use strict';

var obj = {
    name: 'bob',
    school: 'No.1 middle school',
    address: 'xueyuan road'
};
----
var upper = _.map(obj, function (value, key) {
    return ???;
});
----
alert(JSON.stringify(upper));
</pre>
<p>你也许会想，为啥对Object作<code>map()</code>操作的返回结果是<code>Array</code>？应该是Object才合理啊！把<code>_.map</code>换成<code>_.mapObject</code>再试试。</p>
<h4 id="every-some">every / some</h4>
<p>当集合的所有元素都满足条件时，<code>_.every()</code>函数返回<code>true</code>，当集合的至少一个元素满足条件时，<code>_.some()</code>函数返回<code>true</code>：</p>
<pre><code>'use strict';
// 所有元素都大于0？
_.every([1, 4, 7, -3, -9], (x) =&gt; x &gt; 0); // false
// 至少一个元素大于0？
_.some([1, 4, 7, -3, -9], (x) =&gt; x &gt; 0); // true
</code></pre>
<p>当集合是Object时，我们可以同时获得value和key：</p>
<pre class="x-javascript">
'use strict';
var obj = {
    name: 'bob',
    school: 'No.1 middle school',
    address: 'xueyuan road'
};
// 判断key和value是否全部是小写：
----
var r1 = _.every(obj, function (value, key) {
    return ???;
});
var r2 = _.some(obj, function (value, key) {
    return ???;
});
----
alert('every key-value are lowercase: ' + r1 + '\nsome key-value are lowercase: ' + r2);
</pre>
<h4 id="max-min">max / min</h4>
<p>这两个函数直接返回集合中最大和最小的数：</p>
<pre><code>'use strict';
var arr = [3, 5, 7, 9];
_.max(arr); // 9
_.min(arr); // 3

// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：
_.max([])
-Infinity
_.min([])
Infinity
</code></pre>
<p>注意，如果集合是Object，<code>max()</code>和<code>min()</code>只作用于value，忽略掉key：</p>
<pre><code>'use strict';
_.max({ a: 1, b: 2, c: 3 }); // 3
</code></pre>
<h4 id="groupby">groupBy</h4>
<p><code>groupBy()</code>把集合的元素按照key归类，key由传入的函数返回：</p>
<pre><code>'use strict';

var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];
var groups = _.groupBy(scores, function (x) {
    if (x &lt; 60) {
        return 'C';
    } else if (x &lt; 80) {
        return 'B';
    } else {
        return 'A';
    }
});
// 结果:
// {
//   A: [81, 91, 88, 99],
//   B: [75, 77, 66, 72],
//   C: [20, 40, 59]
// }
</code></pre>
<p>可见<code>groupBy()</code>用来分组是非常方便的。</p>
<h4 id="shuffle-sample">shuffle / sample</h4>
<p><code>shuffle()</code>用洗牌算法随机打乱一个集合：</p>
<pre><code>'use strict';
// 注意每次结果都不一样：
_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1]
</code></pre>
<p><code>sample()</code>则是随机选择一个或多个元素：</p>
<pre><code>'use strict';
// 注意每次结果都不一样：
// 随机选1个：
_.sample([1, 2, 3, 4, 5, 6]); // 2
// 随机选3个：
_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4]
</code></pre>
<p>更多完整的函数请参考underscore的文档：<a href="http://underscorejs.org/#collections">http://underscorejs.org/#collections</a></p>
<h2>Arrays</h2>
<p>underscore为<code>Array</code>提供了许多工具类方法，可以更方便快捷地操作<code>Array</code>。</p>
<h4 id="first-last">first / last</h4>
<p>顾名思义，这两个函数分别取第一个和最后一个元素：</p>
<pre><code>'use strict';
var arr = [2, 4, 6, 8];
_.first(arr); // 2
_.last(arr); // 8
</code></pre>
<h4 id="flatten">flatten</h4>
<p><code>flatten()</code>接收一个<code>Array</code>，无论这个<code>Array</code>里面嵌套了多少个<code>Array</code>，<code>flatten()</code>最后都把它们变成一个一维数组：</p>
<pre><code>'use strict';

_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5]
</code></pre>
<h4 id="zip-unzip">zip / unzip</h4>
<p><code>zip()</code>把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。例如，你有一个<code>Array</code>保存了名字，另一个<code>Array</code>保存了分数，现在，要把名字和分数给对上，用<code>zip()</code>轻松实现：</p>
<pre><code>'use strict';

var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.zip(names, scores);
// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]
</code></pre>
<p><code>unzip()</code>则是反过来：</p>
<pre><code>'use strict';
var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]];
_.unzip(namesAndScores);
// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]
</code></pre>
<h4 id="object">object</h4>
<p>有时候你会想，与其用<code>zip()</code>，为啥不把名字和分数直接对应成Object呢？别急，<code>object()</code>函数就是干这个的：</p>
<pre><code>'use strict';

var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.object(names, scores);
// {Adam: 85, Lisa: 92, Bart: 59}
</code></pre>
<p>注意<code>_.object()</code>是一个函数，不是JavaScript的<code>Object</code>对象。</p>
<h4 id="range">range</h4>
<p><code>range()</code>让你快速生成一个序列，不再需要用<code>for</code>循环实现了：</p>
<pre><code>'use strict';

// 从0开始小于10:
_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// 从1开始小于11：
_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 从0开始小于30，步长5:
_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]

// 从0开始大于-10，步长-1:
_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
</code></pre>
<p>更多完整的函数请参考underscore的文档：<a href="http://underscorejs.org/#arrays">http://underscorejs.org/#arrays</a></p>
<h2>Functions</h2>
<p>因为underscore本来就是为了充分发挥JavaScript的函数式编程特性，所以也提供了大量JavaScript本身没有的高阶函数。</p>
<h4 id="bind">bind</h4>
<p><code>bind()</code>有什么用？我们先看一个常见的错误用法：</p>
<pre><code>'use strict';

console.log('Hello, world!');
// 输出'Hello, world!'

var log = console.log;
log('Hello, world!');
// Uncaught TypeError: Illegal invocation
</code></pre>
<p>如果你想用<code>log()</code>取代<code>console.log()</code>，按照上面的做法是不行的，因为直接调用<code>log()</code>传入的<code>this</code>指针是<code>undefined</code>，必须这么用：</p>
<pre><code>'use strict';

var log = console.log;
// 调用call并传入console对象作为this:
log.call(console, 'Hello, world!')
// 输出Hello, world!
</code></pre>
<p>这样搞多麻烦！还不如直接用<code>console.log()</code>。但是，<code>bind()</code>可以帮我们把<code>console</code>对象直接绑定在<code>log()</code>的<code>this</code>指针上，以后调用<code>log()</code>就可以直接正常调用了：</p>
<pre><code>'use strict';

var log = _.bind(console.log, console);
log('Hello, world!');
// 输出Hello, world!
</code></pre>
<h4 id="partial">partial</h4>
<p><code>partial()</code>就是为一个函数创建偏函数。偏函数是什么东东？看例子：</p>
<p>假设我们要计算x<sup>y</sup>，这时只需要调用<code>Math.pow(x, y)</code>就可以了。</p>
<p>假设我们经常计算2<sup>y</sup>，每次都写<code>Math.pow(2, y)</code>就比较麻烦，如果创建一个新的函数能直接这样写<code>pow2N(y)</code>就好了，这个新函数<code>pow2N(y)</code>就是根据<code>Math.pow(x, y)</code>创建出来的偏函数，它固定住了原函数的第一个参数（始终为2）：</p>
<pre><code>'use strict';

var pow2N = _.partial(Math.pow, 2);
pow2N(3); // 8
pow2N(5); // 32
pow2N(10); // 1024
</code></pre>
<p>如果我们不想固定第一个参数，想固定第二个参数怎么办？比如，希望创建一个偏函数<code>cube(x)</code>，计算x<sup>3</sup>，可以用<code>_</code>作占位符，固定住第二个参数：</p>
<pre><code>'use strict';

var cube = _.partial(Math.pow, _, 3);
cube(3); // 27
cube(5); // 125
cube(10); // 1000
</code></pre>
<p>可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度。</p>
<h4 id="memoize">memoize</h4>
<p>如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果。举个例子，计算阶乘就比较耗时：</p>
<pre><code>'use strict';

function factorial(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i &gt; 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
}

factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800
</code></pre>
<p>用<code>memoize()</code>就可以自动缓存函数计算的结果：</p>
<pre><code>'use strict';

var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i &gt; 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
});

// 第一次调用:
factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800

// 第二次调用:
factorial(10); // 3628800
// 控制台没有输出
</code></pre>
<p>对于相同的调用，比如连续两次调用<code>factorial(10)</code>，第二次调用并没有计算，而是直接返回上次计算后缓存的结果。不过，当你计算<code>factorial(9)</code>的时候，仍然会重新计算。</p>
<p>可以对<code>factorial()</code>进行改进，让其递归调用：</p>
<pre><code>'use strict';

var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    if (n &lt; 2) {
        return 1;
    }
    return n * factorial(n - 1);
});

factorial(10); // 3628800
// 输出结果说明factorial(1)~factorial(10)都已经缓存了:
// start calculate 10!...
// start calculate 9!...
// start calculate 8!...
// start calculate 7!...
// start calculate 6!...
// start calculate 5!...
// start calculate 4!...
// start calculate 3!...
// start calculate 2!...
// start calculate 1!...

factorial(9); // 362880
// console无输出
</code></pre>
<h4 id="once">once</h4>
<p>顾名思义，<code>once()</code>保证某个函数执行且仅执行一次。如果你有一个方法叫<code>register()</code>，用户在页面上点两个按钮的任何一个都可以执行的话，就可以用<code>once()</code>保证函数仅调用一次，无论用户点击多少次：</p>
<pre class="x-javascript">
'use strict';
----
var register = _.once(function () {
    alert('Register ok!');
});
----
// 测试效果:
register();
register();
register();
</pre>
<h4 id="delay">delay</h4>
<p><code>delay()</code>可以让一个函数延迟执行，效果和<code>setTimeout()</code>是一样的，但是代码明显简单了：</p>
<pre><code>'use strict';

// 2秒后调用alert():
_.delay(alert, 2000);
</code></pre>
<p>如果要延迟调用的函数有参数，把参数也传进去：</p>
<pre><code>'use strict';

var log = _.bind(console.log, console);
_.delay(log, 2000, 'Hello,', 'world!');
// 2秒后打印'Hello, world!':
</code></pre>
<p>更多完整的函数请参考underscore的文档：<a href="http://underscorejs.org/#functions">http://underscorejs.org/#functions</a></p>
<h2>Objects</h2>
<p>和<code>Array</code>类似，underscore也提供了大量针对Object的函数。</p>
<h4 id="keys-allkeys">keys / allKeys</h4>
<p><code>keys()</code>可以非常方便地返回一个object自身所有的key，但不包含从原型链继承下来的：</p>
<pre><code>'use strict';

function Student(name, age) {
    this.name = name;
    this.age = age;
}

var xiaoming = new Student('小明', 20);
_.keys(xiaoming); // ['name', 'age']
</code></pre>
<p><code>allKeys()</code>除了object自身的key，还包含从原型链继承下来的：</p>
<pre><code>'use strict';

function Student(name, age) {
    this.name = name;
    this.age = age;
}
Student.prototype.school = 'No.1 Middle School';
var xiaoming = new Student('小明', 20);
_.allKeys(xiaoming); // ['name', 'age', 'school']
</code></pre>
<h4 id="values">values</h4>
<p>和<code>keys()</code>类似，<code>values()</code>返回object自身但不包含原型链继承的所有值：</p>
<pre><code>'use strict';

var obj = {
    name: '小明',
    age: 20
};

_.values(obj); // ['小明', 20]
</code></pre>
<p>注意，没有<code>allValues()</code>，原因我也不知道。</p>
<h4 id="mapobject">mapObject</h4>
<p><code>mapObject()</code>就是针对object的map版本：</p>
<pre><code>'use strict';

var obj = { a: 1, b: 2, c: 3 };
// 注意传入的函数签名，value在前，key在后:
_.mapObject(obj, (v, k) =&gt; 100 + v); // { a: 101, b: 102, c: 103 }
</code></pre>
<h4 id="invert">invert</h4>
<p><code>invert()</code>把object的每个key-value来个交换，key变成value，value变成key：</p>
<pre><code>'use strict';

var obj = {
    Adam: 90,
    Lisa: 85,
    Bart: 59
};
_.invert(obj); // { '59': 'Bart', '85': 'Lisa', '90': 'Adam' }
</code></pre>
<h4 id="extend-extendown">extend / extendOwn</h4>
<p><code>extend()</code>把多个object的key-value合并到第一个object并返回：</p>
<pre><code>'use strict';

var a = {name: 'Bob', age: 20};
_.extend(a, {age: 15}, {age: 88, city: 'Beijing'}); // {name: 'Bob', age: 88, city: 'Beijing'}
// 变量a的内容也改变了：
a; // {name: 'Bob', age: 88, city: 'Beijing'}
</code></pre>
<p>注意：如果有相同的key，后面的object的value将覆盖前面的object的value。</p>
<p><code>extendOwn()</code>和<code>extend()</code>类似，但获取属性时忽略从原型链继承下来的属性。</p>
<h4 id="clone">clone</h4>
<p>如果我们要复制一个object对象，就可以用<code>clone()</code>方法，它会把原有对象的所有属性都复制到新的对象中：</p>
<pre class="x-javascript">
'use strict';
var source = {
    name: '小明',
    age: 20,
    skills: ['JavaScript', 'CSS', 'HTML']
};
----
var copied = _.clone(source);
----
alert(JSON.stringify(copied, null, '  '));
</pre>
<p>注意，<code>clone()</code>是“浅复制”。所谓“浅复制”就是说，两个对象相同的key所引用的value其实是同一对象：</p>
<pre><code>source.skills === copied.skills; // true
</code></pre>
<p>也就是说，修改<code>source.skills</code>会影响<code>copied.skills</code>。</p>
<h4 id="isequal">isEqual</h4>
<p><code>isEqual()</code>对两个object进行深度比较，如果内容完全相同，则返回<code>true</code>：</p>
<pre><code>'use strict';

var o1 = { name: 'Bob', skills: { Java: 90, JavaScript: 99 }};
var o2 = { name: 'Bob', skills: { JavaScript: 99, Java: 90 }};

o1 === o2; // false
_.isEqual(o1, o2); // true
</code></pre>
<p><code>isEqual()</code>其实对<code>Array</code>也可以比较：</p>
<pre><code>'use strict';

var o1 = ['Bob', { skills: ['Java', 'JavaScript'] }];
var o2 = ['Bob', { skills: ['Java', 'JavaScript'] }];

o1 === o2; // false
_.isEqual(o1, o2); // true
</code></pre>
<p>更多完整的函数请参考underscore的文档：<a href="http://underscorejs.org/#objects">http://underscorejs.org/#objects</a></p>
<h2>Chaining</h2>
<p>还记得jQuery支持链式调用吗？</p>
<pre><code>$('a').attr('target', '_blank')
      .append(' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;')
      .click(function () {});
</code></pre>
<p>如果我们有一组操作，用underscore提供的函数，写出来像这样：</p>
<pre><code>_.filter(_.map([1, 4, 9, 16, 25], Math.sqrt), x =&gt; x % 2 === 1);
// [1, 3, 5]
</code></pre>
<p>能不能写成链式调用？</p>
<p>能！</p>
<p>underscore提供了把对象包装成能进行链式调用的方法，就是<code>chain()</code>函数：</p>
<pre><code>_.chain([1, 4, 9, 16, 25])
 .map(Math.sqrt)
 .filter(x =&gt; x % 2 === 1)
 .value();
// [1, 3, 5]
</code></pre>
<p>因为每一步返回的都是包装对象，所以最后一步的结果需要调用<code>value()</code>获得最终结果。</p>
<h4 id="-">小结</h4>
<p>通过学习underscore，是不是对JavaScript的函数式编程又有了进一步的认识？</p>
<h1>Node.js</h1>
<p>从本章开始，我们就正式开启JavaScript的后端开发之旅。</p>
<p>Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
<p>众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。（2001年推出的古老的IE 6到今天仍然有人在使用！）</p>
<p>没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。</p>
<p>先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。</p>
<p>随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。</p>
<p>Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。</p>
<p>现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。</p>
<p>浏览器大战和Node有何关系？</p>
<p>话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</p>
<p>因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p>
<p>在Node上运行的JavaScript相比其他后端开发语言有何优势？</p>
<p>最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。</p>
<p>其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过io.js，这又是什么鬼？</p>
</blockquote>
<p>因为Node.js是开源项目，虽然由社区推动，但幕后一直由Joyent公司资助。由于一群开发者对Joyent公司的策略不满，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent公司表示要和解，于是，io.js项目又决定回归Node.js。</p>
<p>具体做法是将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。</p>
<p>本章教程的所有代码都在Node.js上调试通过。如果你要尝试io.js也是可以的，不过两者如果遇到一些区别请自行查看io.js的文档。</p>
<h2>安装Node.js和npm</h2>
<p>由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。</p>
<h4 id="-node-js">安装Node.js</h4>
<p>目前Node.js的最新版本是5.3.x。首先，从<a href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，网速慢的童鞋请移步<a href="http://pan.baidu.com/s/1kTpIQiF#path=%252Fnodejs">国内镜像</a>。</p>
<p>在Windows上安装时务必选择全部组件，包括勾选<code>Add to Path</code>。</p>
<p>安装完成后，在Windows环境下，请打开命令提示符，然后输入<code>node -v</code>，如果安装正常，你应该看到<code>v5.3.0</code>这样的输出：</p>
<pre><code>C:\Users\IEUser&gt;node -v
v5.3.0
</code></pre>
<p>继续在命令提示符输入<code>node</code>，此刻你将进入Node.js的交互环境。在交互环境下，你可以输入任意JavaScript语句，例如<code>100+200</code>，回车后将得到输出结果。</p>
<p>要退出Node.js环境，连按两次Ctrl+C。</p>
<video width="640" height="360" controls>
<source src="http://michaelliao.gitcafe.io/video/node/install-node.mp4">
<source src="http://github.liaoxuefeng.com/sinaweibopy/video/node/install-node.mp4">
</source></source></video>
<p>在Mac或Linux环境下，请打开终端，然后输入<code>node -v</code>，你应该看到如下输出：</p>
<pre><code>$ node -v
v5.3.0
</code></pre>
<p>如果版本号不是<code>5.3.x</code>，说明Node.js版本不对，后面章节的代码不保证能正常运行，请重新安装最新版本。</p>
<h4 id="npm">npm</h4>
<p>在正式开始Node.js学习之前，我们先认识一下npm。</p>
<p>npm是什么东东？npm其实是Node.js的包管理工具（package manager）。</p>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm究竟在哪？</p>
<p>其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>，应该看到类似的输出：</p>
<pre><code>C:\&gt;npm -v
3.3.12
</code></pre>
<p>如果直接输入<code>npm</code>，你会看到类似下面的输出：</p>
<pre><code>C:\&gt; npm

Usage: npm &lt;command&gt;

where &lt;command&gt; is one of:
    ...
</code></pre>
<p>上面的一大堆文字告诉你，<code>npm</code>需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。</p>
<h4 id="-">小结</h4>
<p>请在本机安装Node.js环境，并确保<code>node</code>和<code>npm</code>能正常运行。</p>
<h2>第一个Node程序</h2>
<p>在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的JavaScript代码将<em>不能</em>在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
<p>那么问题来了：文本编辑器到底哪家强？</p>
<p>推荐两款文本编辑器：</p>
<p>一个是<a href="http://www.sublimetext.com/">Sublime Text</a>，免费使用，但是不付费会弹出提示框：</p>
<p><img src="files/attachments/0014391203656031cca7d66502f4d9a93d9c0ee3b22c5e1000.png" alt="hello.js"></p>
<p>一个是<a href="http://notepad-plus-plus.org/">Notepad++</a>，免费使用，有中文界面：</p>
<p><img src="files/attachments/0014391205903808ed663ec86204145be2f0a3787a13db4000.png" alt="notepad-hello.js"></p>
<p>请注意，用哪个都行，但是<span style="color:red">绝对不能用Word和写字板，Windows自带的记事本也强烈不推荐使用</span>。Word和写字板保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。</p>
<p>安装好文本编辑器后，输入以下代码：</p>
<pre><code>'use strict';

console.log('Hello, world.');
</code></pre>
<p>第一行总是写上<code>'use strict';</code>是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如<code>C:\Workspace</code>，把文件保存为<code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到<code>hello.js</code>所在目录，然后输入以下命令运行这个程序了：</p>
<pre><code>C:\Workspace&gt;node hello.js
Hello, world.
</code></pre>
<p>也可以保存为别的名字，比如<code>first.js</code>，但是必须要以<code>.js</code>结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有<code>hello.js</code>这个文件，运行<code>node hello.js</code>就会报错：</p>
<pre><code>C:\Workspace&gt;node hello.js
module.js:338
    throw err;
          ^
Error: Cannot find module 'C:\Workspace\hello.js'
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
</code></pre>
<p>报错的意思就是，没有找到<code>hello.js</code>这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h4 id="-node-">命令行模式和Node交互模式</h4>
<p>请注意区分命令行模式和Node交互模式。</p>
<p>看到类似<code>C:\&gt;</code>是在Windows提供的命令行模式：</p>
<p><img src="files/attachments/00143912121754934a42330afe74908a7d305faf0272f21000.png" alt="run-node-hello"></p>
<p>在命令行模式下，可以执行<code>node</code>进入Node交互式环境，也可以执行<code>node hello.js</code>运行一个<code>.js</code>文件。</p>
<p>看到<code>&gt;</code>是在Node交互式环境下：</p>
<p><img src="files/attachments/0014391212294193de526e6aab945c18a48203cd694f6dd000.png" alt="node-interactive-env"></p>
<p>在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。</p>
<p>此外，在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。</p>
<p>例如，在Node交互式环境下，输入：</p>
<pre><code>&gt; 100 + 200 + 300;
600
</code></pre>
<p>直接可以看到结果<code>600</code>。</p>
<p>但是，写一个<code>calc.js</code>的文件，内容如下：</p>
<pre><code>100 + 200 + 300;
</code></pre>
<p>然后在命令行模式下执行：</p>
<pre><code>C:\Workspace&gt;node calc.js
</code></pre>
<p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用<code>console.log()</code>打印出来。把<code>calc.js</code>改造一下：</p>
<pre><code>console.log(100 + 200 + 300);
</code></pre>
<p>再执行，就可以看到结果：</p>
<pre><code>C:\Workspace&gt;node calc.js
600
</code></pre>
<h4 id="-">小结</h4>
<p>用文本编辑器写JavaScript程序，然后保存为后缀为<code>.js</code>的文件，就可以用node直接运行这个程序了。</p>
<p>Node的交互模式和直接运行<code>.js</code>文件有什么区别呢？</p>
<p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p>
<p>在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！</p>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/blob/master/samples/node/basic/hello.js">hello.js</a></p>
<h2>模块</h2>
<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p>
<p>使用模块有什么好处？</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<p>在上一节，我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块。</p>
<p>我们把<code>hello.js</code>改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：</p>
<pre><code>'use strict';

var s = 'Hello';

function greet(name) {
    console.log(s + ', ' + name + '!');
}

module.exports = greet;
</code></pre>
<p>函数<code>greet()</code>是我们在<code>hello</code>模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数<code>greet</code>作为模块的输出暴露出去，这样其他模块就可以使用<code>greet</code>函数了。</p>
<p>问题是其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>
<pre><code>'use strict';

// 引入hello模块:
var greet = require('./hello');

var s = 'Michael';

greet(s); // Hello, Michael!
</code></pre>
<p>注意到引入<code>hello</code>模块用Node提供的<code>require</code>函数：</p>
<pre><code>var greet = require('./hello');
</code></pre>
<p>引入的模块作为变量保存在<code>greet</code>变量中，那<code>greet</code>变量到底是什么东西？其实变量<code>greet</code>就是在<code>hello.js</code>中我们用<code>module.exports = greet;</code>输出的<code>greet</code>函数。所以，<code>main.js</code>就成功地引用了<code>hello.js</code>模块中定义的<code>greet()</code>函数，接下来就可以直接使用它了。</p>
<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>
<pre><code>var greet = require('./hello'); // 不要忘了写相对目录!
</code></pre>
<p>如果只写模块名：</p>
<pre><code>var greet = require('hello');
</code></pre>
<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>
<pre><code>module.js
    throw err;
          ^
Error: Cannot find module 'hello'
    at Function.Module._resolveFilename
    at Function.Module._load
    ...
    at Function.Module._load
    at Function.Module.runMain
</code></pre>
<p>遇到这个错误，你要检查：</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h4 id="commonjs-">CommonJS规范</h4>
<p>这种模块加载机制被称为CommonJS规范。在这个规范下，每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code>和<code>main.js</code>都申明了全局变量<code>var s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require('module_name');</code>就拿到了引用模块的变量。</p>
<h4 id="-">结论</h4>
<p>要在模块中对外输出变量，用：</p>
<pre><code>module.exports = variable;
</code></pre>
<p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用：</p>
<pre><code>var foo = require('other_module');
</code></pre>
<p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h4 id="-">深入了解模块原理</h4>
<p>如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。</p>
<p>当我们编写JavaScript代码时，我们可以申明全局变量：</p>
<pre><code>var s = 'global';
</code></pre>
<p>在浏览器中，大量使用全局变量可不好。如果你在<code>a.js</code>中使用了全局变量<code>s</code>，那么，在<code>b.js</code>中也使用全局变量<code>s</code>，将造成冲突，<code>b.js</code>中对<code>s</code>赋值会改变<code>a.js</code>的运行逻辑。</p>
<p>也就是说，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那Node.js是如何实现这一点的？</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的<code>hello.js</code>代码是这样的：</p>
<pre><code>var s = 'Hello';
var name = 'world';

console.log(s + ' ' + name + '!');
</code></pre>
<p>Node.js加载了<code>hello.js</code>后，它可以把代码包装一下，变成这样执行：</p>
<pre><code>(function () {
    // 读取的hello.js代码:
    var s = 'Hello';
    var name = 'world';

    console.log(s + ' ' + name + '!');
    // hello.js代码结束
})();
</code></pre>
<p>这样一来，原来的全局变量<code>s</code>现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量<code>s</code>也互不干扰。</p>
<p>所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出<code>module.exports</code>怎么实现？</p>
<p>这个也很容易实现，Node可以先准备一个对象<code>module</code>：</p>
<pre><code>// 准备module对象:
var module = {
    id: 'hello',
    exports: {}
};
var load = function (module) {
    // 读取的hello.js代码:
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }

    module.exports = greet;
    // hello.js代码结束
    return module.exports;
};
var exported = load(module);
// 保存module:
save(module, exported);
</code></pre>
<p>可见，变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数：</p>
<pre><code>module.exports = greet;
</code></pre>
<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>
<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取module时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出：</p>
<pre><code>var greet = require('./hello');
</code></pre>
<p>以上是Node实现JavaScript模块的一个简单的原理介绍。</p>
<h4 id="module-exports-vs-exports">module.exports vs exports</h4>
<p>很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：</p>
<p>方法一：对module.exports赋值：</p>
<pre><code>// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

module.exports = {
    hello: hello,
    greet: greet
};
</code></pre>
<p>方法二：直接使用exports：</p>
<pre><code>// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

exports.hello = hello;
exports.greet = greet;
</code></pre>
<p>但是你不可以直接对<code>exports</code>赋值：</p>
<pre><code>// 代码可以执行，但是模块并没有输出任何变量:
exports = {
    hello: hello,
    greet: greet
};
</code></pre>
<p>如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：</p>
<p>首先，Node会把整个待加载的<code>hello.js</code>文件放入一个包装函数<code>load</code>中执行。在执行这个<code>load()</code>函数前，Node准备好了module变量：</p>
<pre><code>var module = {
    id: 'hello',
    exports: {}
};
</code></pre>
<p><code>load()</code>函数最终返回<code>module.exports</code>：</p>
<pre><code>var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exported = load(module.exports, module);
</code></pre>
<p>也就是说，默认情况下，Node准备的<code>exports</code>变量和<code>module.exports</code>变量实际上是同一个变量，并且初始化为空对象<code>{}</code>，于是，我们可以写：</p>
<pre><code>exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };
</code></pre>
<p>也可以写：</p>
<pre><code>module.exports.foo = function () { return 'foo'; };
module.exports.bar = function () { return 'bar'; };
</code></pre>
<p>换句话说，Node默认给你准备了一个空对象<code>{}</code>，这样你可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给<code>module.exports</code>赋值：</p>
<pre><code>module.exports = function () { return 'foo'; };
</code></pre>
<p>给<code>exports</code>赋值是无效的，因为赋值后，<code>module.exports</code>仍然是空对象<code>{}</code>。</p>
<h4 id="-">结论</h4>
<p>如果要输出一个键值对象<code>{}</code>，可以利用<code>exports</code>这个已存在的空对象<code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>
<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>
<pre><code>module.exports = {
    foo: function () { return 'foo'; }
};
</code></pre>
<p>或者：</p>
<pre><code>module.exports = function () { return 'foo'; };
</code></pre>
<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>
<h4 id="-">练习</h4>
<p>编写<code>hello.js</code>，输出一个或多个函数；</p>
<p>编写<code>main.js</code>，引入<code>hello</code>模块，调用其函数。</p>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/blob/master/samples/node/module/hello.js">hello.js</a></p>
<p><a href="https://github.com/michaelliao/learn-javascript/blob/master/samples/node/module/main.js">main.js</a></p>
<h2>基本模块</h2>
<p>因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。</p>
<h4 id="global">global</h4>
<p>在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，但不叫<code>window</code>，而叫<code>global</code>，这个对象的属性和方法也和浏览器环境的<code>window</code>不同。进入Node.js交互环境，可以直接输入：</p>
<pre><code>&gt; global.console
Console {
  log: [Function: bound ],
  info: [Function: bound ],
  warn: [Function: bound ],
  error: [Function: bound ],
  dir: [Function: bound ],
  time: [Function: bound ],
  timeEnd: [Function: bound ],
  trace: [Function: bound trace],
  assert: [Function: bound ],
  Console: [Function: Console] }
</code></pre>
<h4 id="process">process</h4>
<p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>
<pre><code>&gt; process === global.process;
true
&gt; process.version;
'v5.2.0'
&gt; process.platform;
'darwin'
&gt; process.arch;
'x64'
&gt; process.cwd(); //返回当前工作目录
'/Users/michael'
&gt; process.chdir('/private/tmp'); // 切换当前工作目录
undefined
&gt; process.cwd();
'/private/tmp'
</code></pre>
<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>
<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>
<pre><code>// test.js

// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
    console.log('nextTick callback!');
});
console.log('nextTick was set!');
</code></pre>
<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>
<pre><code>nextTick was set!
nextTick callback!
</code></pre>
<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>
<pre><code>// 程序即将退出时的回调函数:
process.on('exit', function (code) {
    console.log('about to exit with code: ' + code);
});
</code></pre>
<h4 id="-javascript-">判断JavaScript执行环境</h4>
<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<pre><code>if (typeof(window) === 'undefined') {
    console.log('node.js');
} else {
    console.log('browser');
}
</code></pre>
<p>后面，我们将介绍Node.js的常用内置模块。</p>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/blob/master/samples/node/global/gl.js">gl.js</a></p>
<h3>fs</h3>
<p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p>
<p>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。</p>
<p>回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的<code>getJSON()</code>操作：</p>
<pre><code>$.getJSON('http://example.com/ajax', function (data) {
    console.log('IO结果返回后执行...');
});
console.log('不等待IO结果直接执行后续代码...');
</code></pre>
<p>而同步的IO操作则需要等待函数返回：</p>
<pre><code>// 根据网络耗时，函数将执行几十毫秒~几秒不等:
var data = getJSONSync('http://example.com/ajax');
</code></pre>
<p>同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。</p>
<h4 id="-">异步读文件</h4>
<p>按照JavaScript的标准，异步读取一个文本文件的代码如下：</p>
<pre><code>'use strict';

var fs = require('fs');

fs.readFile('sample.txt', 'utf-8', function (err, data) {
    if (err) {
        console.log(err);
    } else {
        console.log(data);
    }
});
</code></pre>
<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>
<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</p>
<p>由于<code>err</code>是否为<code>null</code>就是判断是否出错的标志，所以通常的判断逻辑总是：</p>
<pre><code>if (err) {
    // 出错了
} else {
    // 正常
}
</code></pre>
<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>
<p>下面的例子演示了如何读取一个图片文件：</p>
<pre><code>'use strict';

var fs = require('fs');

fs.readFile('sample.png', function (err, data) {
    if (err) {
        console.log(err);
    } else {
        console.log(data);
        console.log(data.length + ' bytes');
    }
});
</code></pre>
<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>
<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>
<pre><code>// Buffer -&gt; String
var text = data.toString('utf-8');
console.log(text);
</code></pre>
<p>或者把一个String转换成<code>Buffer</code>：</p>
<pre><code>// String -&gt; Buffer
var buf = new Buffer(text, 'utf-8');
console.log(buf);
</code></pre>
<h4 id="-">同步读文件</h4>
<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>
<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>
<pre><code>'use strict';

var fs = require('fs');

var data = fs.readFileSync('sample.txt', 'utf-8');
console.log(data);
</code></pre>
<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>
<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</p>
<pre><code>try {
    var data = fs.readFileSync('sample.txt', 'utf-8');
    console.log(data);
} catch (err) {
    // 出错了
}
</code></pre>
<h4 id="-">写文件</h4>
<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>
<pre><code>'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFile('output.txt', data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log('ok.');
    }
});
</code></pre>
<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>
<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>
<pre><code>'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);
</code></pre>
<h4 id="stat">stat</h4>
<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>
<pre><code>'use strict';

var fs = require('fs');

fs.stat('sample.txt', function (err, stat) {
    if (err) {
        console.log(err);
    } else {
        // 是否是文件:
        console.log('isFile: ' + stat.isFile());
        // 是否是目录:
        console.log('isDirectory: ' + stat.isDirectory());
        if (stat.isFile()) {
            // 文件大小:
            console.log('size: ' + stat.size);
            // 创建时间, Date对象:
            console.log('birth time: ' + stat.birthtime);
            // 修改时间, Date对象:
            console.log('modified time: ' + stat.mtime);
        }
    }
});
</code></pre>
<p>运行结果如下：</p>
<pre><code>isFile: true
isDirectory: false
size: 181
birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)
modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)
</code></pre>
<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>
<h4 id="-">异步还是同步</h4>
<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>
<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>
<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/tree/master/samples/node/fs">用fs读写文件</a></p>
<h3>stream</h3>
<p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>
<p><img src="files/attachments/0014506644402990b6e40e7b0944670833a00355be94e34000.png" alt="nodejs-stream"></p>
<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>
<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<p>下面是一个从文件流读取文本内容的示例：</p>
<pre><code>'use strict';

var fs = require('fs');

// 打开一个流:
var rs = fs.createReadStream('sample.txt', 'utf-8');

rs.on('data', function (chunk) {
    console.log('DATA:')
    console.log(chunk);
});

rs.on('end', function () {
    console.log('END');
});

rs.on('error', function (err) {
    console.log('ERROR: ' + err);
});
</code></pre>
<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>
<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<pre><code>'use strict';

var fs = require('fs');

var ws1 = fs.createWriteStream('output1.txt', 'utf-8');
ws1.write('使用Stream写入文本数据...\n');
ws1.write('END.');
ws1.end();

var ws2 = fs.createWriteStream('output2.txt');
ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));
ws2.write(new Buffer('END.', 'utf-8'));
ws2.end();
</code></pre>
<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>
<h4 id="pipe">pipe</h4>
<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>
<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>
<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>
<pre><code>'use strict';

var fs = require('fs');

var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');

rs.pipe(ws);
</code></pre>
<p>默认情况下，当<code>Readable</code>流的数据读取完毕，<code>end</code>事件触发后，将自动关闭<code>Writable</code>流。如果我们不希望自动关闭<code>Writable</code>流，需要传入参数：</p>
<pre><code>readable.pipe(writable, { end: false });
</code></pre>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/tree/master/samples/node/stream">stream</a></p>
<h3>http</h3>
<p>Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的<em>全栈</em>了。</p>
<h4 id="http-">HTTP协议</h4>
<p>要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432011939547478fd5482deb47b08716557cc99764e0000">HTTP协议简介</a>。</p>
<h4 id="http-">HTTP服务器</h4>
<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<pre><code>'use strict';

// 导入http模块:
var http = require('http');

// 创建http server，并传入回调函数:
var server = http.createServer(function (request, response) {
    // 回调函数接收request和response对象,
    // 获得HTTP请求的method和url:
    console.log(request.method + ': ' + request.url);
    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:
    response.writeHead(200, {'Content-Type': 'text/html'});
    // 将HTTP响应的HTML内容写入response:
    response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');
});

// 让服务器监听8080端口:
server.listen(8080);

console.log('Server is running at http://127.0.0.1:8080/');
</code></pre>
<p>在命令提示符下运行该程序，可以看到以下输出：</p>
<pre><code>$ node hello.js
Server is running at http://127.0.0.1:8080/
</code></pre>
<p>不要关闭命令提示符，直接打开浏览器输入<code>http://localhost:8080</code>，即可看到服务器响应的内容：</p>
<p><img src="files/attachments/0014507141527539080883467c246e184f45b360d125814000.jpeg" alt="http-hello-sample"></p>
<p>同时，在命令提示符窗口，可以看到程序打印的请求信息：</p>
<pre><code>GET: /
GET: /favicon.ico
</code></pre>
<p>这就是我们编写的第一个HTTP服务器程序！</p>
<h4 id="-">文件服务器</h4>
<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>
<pre><code>'use strict';

var url = require('url');

console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));
</code></pre>
<p>结果如下：</p>
<pre><code>Url {
  protocol: 'http:',
  slashes: true,
  auth: 'user:pass',
  host: 'host.com:8080',
  port: '8080',
  hostname: 'host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/path/to/file',
  path: '/path/to/file?query=string',
  href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }
</code></pre>
<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<pre><code>'use strict';

var path = require('path');

// 解析当前目录:
var workDir = path.resolve('.'); // '/Users/michael'

// 组合完整的文件路径:当前目录+'pub'+'index.html':
var filePath = path.join(workDir, 'pub', 'index.html');
// '/Users/michael/pub/index.html'
</code></pre>
<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\michael\static\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>
<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>
<pre><code>'use strict';

var
    fs = require('fs'),
    url = require('url'),
    path = require('path'),
    http = require('http');

// 从命令行参数获取root目录，默认是当前目录:
var root = path.resolve(process.argv[2] || '.');

console.log('Static root dir: ' + root);

// 创建服务器:
var server = http.createServer(function (request, response) {
    // 获得URL的path，类似 '/css/bootstrap.css':
    var pathname = url.parse(request.url).pathname;
    // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':
    var filepath = path.join(root, pathname);
    // 获取文件状态:
    fs.stat(filepath, function (err, stats) {
        if (!err &amp;&amp; stats.isFile()) {
            // 没有出错并且文件存在:
            console.log('200 ' + request.url);
            // 发送200响应:
            response.writeHead(200);
            // 将文件流导向response:
            fs.createReadStream(filepath).pipe(response);
        } else {
            // 出错了或者文件不存在:
            console.log('404 ' + request.url);
            // 发送404响应:
            response.writeHead(404);
            response.end('404 Not Found');
        }
    });
});

server.listen(8080);

console.log('Server is running at http://127.0.0.1:8080/');
</code></pre>
<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>
<p><img src="files/attachments/00145071557176340f646d8f6534e9a8f5afb4144de2ac8000.png" alt="http-index-page"></p>
<p>只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。观察控制台输出：</p>
<pre><code>200 /index.html
200 /css/uikit.min.css
200 /js/jquery.min.js
200 /fonts/fontawesome-webfont.woff2
</code></pre>
<p>第一个请求是浏览器请求<code>index.html</code>页面，后续请求是浏览器解析HTML后发送的其它资源请求。</p>
<h4 id="-">练习</h4>
<p>在浏览器输入<code>http://localhost:8080/</code>时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改<code>file_server.js</code>，如果遇到请求的路径是目录，则自动在目录下依次搜索<code>index.html</code>、<code>default.html</code>，如果找到了，就返回HTML文件的内容。</p>
<h4 id="-">参考源码</h4>
<p><a href="https://github.com/michaelliao/learn-javascript/tree/master/samples/node/http">http服务器代码</a>（含静态网站）</p>
<h3>buffer</h3>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h2>Web开发</h2>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h3>koa</h3>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h3>mysql</h3>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h3>swig</h3>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h2>自动化工具</h2>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
<h1>期末总结</h1>
<p>即将推出，请耐心等待。等待不耐烦的，请关注微博<a href="http://www.weibo.com/liaoxuefeng">@廖雪峰</a></p>
</div>
<script src="../app.js"></script>
</body>
</html>
